<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>统计分布模拟分析工具</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="i18n.js"></script>
    <script src="dashscope_integration.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cb7;
            --accent-color: #f9a03f;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --background-color: #f5f7fa;
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: var(--shadow);
            position: relative;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* 统计卡片网格布局 */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stats-container {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--card-background);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
        }
        
        .stats-container h3 {
            margin-top: 0;
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background-color: white;
            border-radius: 8px 8px 0 0;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background-color: rgba(74, 111, 165, 0.05);
        }
        
        .tab.active {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary-color);
        }
        
        .tab-content {
            background-color: white;
            border-radius: 0 0 8px 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            min-height: 500px;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        button:hover {
            background-color: var(--secondary-color);
        }
        
        button.secondary {
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        button.secondary:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .button-group {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background-color: var(--background-color);
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
        }
        
        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .hidden {
            display: none;
        }
        
        /* 假设检验结果高亮样式 */
        .highlight-reject {
            background-color: #ffebee;
            border-left-color: #f44336;
            border-left-width: 5px;
        }
        
        .highlight-accept {
            background-color: #e8f5e9;
            border-left-color: #4caf50;
            border-left-width: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 9999;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--success-color);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .help-text {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 5px;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .badge-warning {
            background-color: var(--warning-color);
            color: white;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1 data-i18n="app.title">统计分布模拟分析工具</h1>
            <p class="subtitle" data-i18n="app.subtitle">通过模拟不同概率分布，进行数据分析与可视化</p>
        </div>
    </header>
    
    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="distribution" data-i18n="tab.distribution">概率分布模拟</button>
            <button class="tab" data-tab="confidence" data-i18n="tab.confidence">置信区间分析</button>
            <button class="tab" data-tab="analysis" data-i18n="tab.dataAnalysis">数据分析</button>
            <button class="tab" data-tab="hypothesis" data-i18n="tab.hypothesis">假设检验</button>
        </div>
        
        <div id="hypothesis" class="tab-content hidden">
            <h2 data-i18n="tab.hypothesis">假设检验</h2>
            
            <div class="card">
                <h3 data-i18n="test.settings">检验设置</h3>
                
                <div class="form-group">
                    <label for="test-type" data-i18n="stats.testType">检验类型</label>
                    <select id="test-type">
                        <option value="z-test" data-i18n="z.test">单样本Z检验</option>
                        <option value="t-test" data-i18n="t.test">单样本T检验</option>
                        <option value="two-sample-t" data-i18n="test.twoSample">双样本T检验</option>
                        <option value="anova" data-i18n="test.anova">单因素方差分析</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="significance-level" data-i18n="hypothesis.significanceLevel">显著性水平 (α)</label>
                        <select id="significance-level">
                            <option value="0.01">0.01</option>
                            <option value="0.05" selected>0.05</option>
                            <option value="0.10">0.10</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="test-direction" data-i18n="test.direction">检验方向</label>
                        <select id="test-direction">
                            <option value="two-tailed" selected data-i18n="test.twoTailed">双侧检验</option>
                            <option value="left-tailed" data-i18n="test.leftTailed">左侧检验</option>
                            <option value="right-tailed" data-i18n="test.rightTailed">右侧检验</option>
                        </select>
                    </div>
                </div>
                
                <div id="one-sample-params">
                    <h4 data-i18n="test.oneSampleParams">单样本检验参数</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="population-mean" data-i18n="confidence.hypothesizedMean">假设总体均值 (μ₀)</label>
                            <input type="number" id="population-mean" value="0" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label for="population-std" data-i18n="stats.population.std">总体标准差 (σ) <span class="help-text" data-i18n="test.neededForZTest">(Z检验需要)</span></label>
                            <input type="number" id="population-std" value="1" step="0.1" min="0.01">
                        </div>
                    </div>
                </div>
                
                <div id="two-sample-params" class="hidden">
                    <h4 data-i18n="test.twoSampleParams">双样本检验参数</h4>
                    <div class="form-group">
                        <label for="sample-method" data-i18n="test.sampleMethod">样本选择方式</label>
                        <select id="sample-method">
                            <option value="use-generated" data-i18n="test.useGeneratedData">使用已生成的数据</option>
                            <option value="manual-entry" data-i18n="test.manualEntry">手动输入</option>
                        </select>
                    </div>
                    <div id="manual-sample-input" class="hidden">
                        <div class="form-group">
                            <label for="sample1-data" data-i18n="test.sample1Data">样本1数据 (逗号分隔)</label>
                            <textarea id="sample1-data" rows="4" placeholder="例如: 1,2,3,4,5" data-i18n-placeholder="test.sampleDataPlaceholder"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="sample2-data" data-i18n="test.sample2Data">样本2数据 (逗号分隔)</label>
                            <textarea id="sample2-data" rows="4" placeholder="例如: 2,3,4,5,6" data-i18n-placeholder="test.sampleDataPlaceholder"></textarea>
                        </div>
                    </div>
                </div>
                
                <div id="anova-params" class="hidden">
                    <h4 data-i18n="test.anovaParams">方差分析参数</h4>
                    <div class="form-group">
                        <p data-i18n="test.anovaRequiresData">方差分析需要至少两组数据，请使用手动输入方式。</p>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calculate-test" class="btn btn-primary" data-i18n="button.calculate.test">计算假设检验</button>
                    <button id="clear-test-results" class="btn btn-secondary" data-i18n="button.clearResults">清除结果</button>
                </div>
            </div>
            
            <div id="test-results" class="hidden">
                <h3 data-i18n="test.results">检验结果</h3>
                <div class="stats-container">
                    <div id="test-summary" class="stats-grid"></div>
                </div>
                
                <div id="test-chart-container" class="chart-container hidden">
                    <canvas id="test-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="distribution" class="tab-content">
            <h2 data-i18n="tab.distribution">概率分布模拟</h2>
            
            <div class="form-group">
                <label for="distribution-type" data-i18n="distribution.type">分布类型</label>
                <select id="distribution-type">
                    <option value="normal" data-i18n="distribution.normal">正态分布</option>
                    <option value="binomial" data-i18n="distribution.binomial">二项分布</option>
                    <option value="poisson" data-i18n="distribution.poisson">泊松分布</option>
                    <option value="uniform" data-i18n="distribution.uniform">均匀分布</option>
                    <option value="exponential" data-i18n="distribution.exponential">指数分布</option>
                </select>
            </div>
            
            <!-- 正态分布参数 -->
            <div id="normal-params" class="param-group">
                <div class="form-row">
                    <div class="form-group">
                        <label for="normal-mean" data-i18n="param.mean">均值 (μ)</label>
                        <input type="number" id="normal-mean" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="normal-std" data-i18n="param.std">标准差 (σ)</label>
                        <input type="number" id="normal-std" value="1" step="0.1" min="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- 二项分布参数 -->
            <div id="binomial-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="binomial-n" data-i18n="param.trials">试验次数 (n)</label>
                        <input type="number" id="binomial-n" value="10" step="1" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="binomial-p" data-i18n="param.probability">成功概率 (p)</label>
                        <input type="number" id="binomial-p" value="0.5" step="0.01" min="0" max="1" required>
                    </div>
                </div>
            </div>
            
            <!-- 泊松分布参数 -->
            <div id="poisson-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="poisson-lambda" data-i18n="param.lambda">速率参数 (λ)</label>
                        <input type="number" id="poisson-lambda" value="5" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <!-- 均匀分布参数 -->
            <div id="uniform-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="uniform-min" data-i18n="param.min">最小值 (a)</label>
                        <input type="number" id="uniform-min" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="uniform-max" data-i18n="param.max">最大值 (b)</label>
                        <input type="number" id="uniform-max" value="1" step="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- 指数分布参数 -->
            <div id="exponential-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="exponential-lambda">速率参数 (λ)</label>
                        <input type="number" id="exponential-lambda" value="1" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="sample-size" data-i18n="param.sampleSize">样本大小</label>
                <input type="number" id="sample-size" value="1000" step="100" min="100" max="10000" required>
            </div>
            
            <div class="button-group">
                <button id="generate-data" data-i18n="button.generateData">生成数据</button>
                <button id="clear-data" class="secondary" data-i18n="button.clearData">清除数据</button>
            </div>
            
            <div id="distribution-chart-container" class="chart-container hidden">
                <canvas id="distribution-chart"></canvas>
            </div>
            
            <div id="distribution-stats" class="stats-grid hidden"></div>
        </div>
        
        <div id="confidence" class="tab-content hidden">
            <h2 data-i18n="tab.confidence">置信区间分析</h2>
            
            <div class="card">
                <h3 data-i18n="confidence.method">分析设置</h3>
                
                <div class="form-group">
                    <label data-i18n="confidence.method">数据输入方式</label>
                    <div>
                        <label><input type="radio" name="confidence-data-method" value="sample" checked> 使用样本数据</label>
                        <label><input type="radio" name="confidence-data-method" value="population" style="margin-left: 20px;"> 使用总体参数</label>
                        <label><input type="radio" name="confidence-data-method" value="generate" style="margin-left: 20px;"> 生成随机样本</label>
                    </div>
                </div>
                
                <div id="sample-data-section">
                    <div class="form-group">
                        <label for="sample-data" data-i18n="confidence.sampleData">样本数据 (逗号分隔)</label>
                        <textarea id="sample-data" rows="4" placeholder="例如: 1,2,3,4,5,6,7,8,9,10"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="confidence-test-type" data-i18n="confidence.method">检验方法</label>
                        <select id="confidence-test-type">
                            <option value="z-test" data-i18n="z.test">Z检验 (已知总体标准差)</option>
                            <option value="t-test" data-i18n="t.test" selected>T检验 (未知总体标准差)</option>
                        </select>
                    </div>
                    <div id="sample-std-section" class="form-group hidden">
                        <label for="sample-population-std">总体标准差 (σ)</label>
                        <input type="number" id="sample-population-std" value="1" step="0.1" min="0.1">
                    </div>
                </div>
                
                <div id="population-data-section" class="hidden">
                    <div class="form-group">
                        <label for="confidence-level" data-i18n="confidence.level">置信水平</label>
                        <select id="confidence-level">
                            <option value="0.90">90%</option>
                            <option value="0.95" selected>95%</option>
                            <option value="0.99">99%</option>
                            <option value="0.999">99.9%</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="population-mean" data-i18n="confidence.sampleMean">样本均值 (x̄)</label>
                        <input type="number" id="population-mean" value="0" step="0.1" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="population-std" data-i18n="confidence.populationStd">标准差</label>
                        <select id="std-type">
                            <option value="population" data-i18n="population.std">总体标准差 (σ)</option>
                            <option value="sample" data-i18n="sample.std">样本标准差 (s)</option>
                        </select>
                        <input type="number" id="population-std" value="1" step="0.1" min="0.1" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="sample-size-confidence" data-i18n="confidence.sampleSize">样本大小</label>
                        <input type="number" id="sample-size-confidence" value="30" step="1" min="1" required>
                    </div>
                </div>
                
                <div id="generate-data-section" class="hidden">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="generate-distribution" data-i18n="distribution.type">分布类型</label>
                            <select id="generate-distribution">
                                <option value="normal" data-i18n="distribution.normal">正态分布</option>
                                <option value="uniform" data-i18n="distribution.uniform">均匀分布</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="generate-mean" data-i18n="param.mean">均值</label>
                            <input type="number" id="generate-mean" value="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="generate-std" data-i18n="param.std">标准差</label>
                            <input type="number" id="generate-std" value="1" step="0.1" min="0.1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="generate-sample-size" data-i18n="confidence.sampleSize">样本大小</label>
                            <input type="number" id="generate-sample-size" value="30" step="1" min="1">
                        </div>
                        <div class="form-group">
                            <label for="generate-confidence-level" data-i18n="confidence.level">置信水平</label>
                            <select id="generate-confidence-level">
                                <option value="0.90">90%</option>
                                <option value="0.95" selected>95%</option>
                                <option value="0.99">99%</option>
                            </select>
                        </div>
                    </div>
                    <button id="generate-confidence-sample" class="secondary" data-i18n="confidence.generateSample">生成样本并分析</button>
                </div>
                
                <div class="button-group">
                    <button id="calculate-confidence" data-i18n="confidence.calculate">计算置信区间</button>
                    <button id="calculate-sample-size" class="secondary" data-i18n="confidence.calculateSampleSize">计算所需样本量</button>
                    <button id="clear-confidence-results" class="secondary" data-i18n="button.clear">清除结果</button>
                </div>
            </div>
            
            <div id="sample-size-calculator" class="card hidden">
                <h3 data-i18n="confidence.calculateSampleSize">样本量计算</h3>
                <div class="form-row">
                    <div class="form-group">
                        <label for="margin-error" data-i18n="confidence.marginError">期望边际误差</label>
                        <input type="number" id="margin-error" value="0.5" step="0.01" min="0.01">
                    </div>
                    <div class="form-group">
                        <label for="ss-confidence-level" data-i18n="confidence.level">置信水平</label>
                        <select id="ss-confidence-level">
                            <option value="0.90">90%</option>
                            <option value="0.95" selected>95%</option>
                            <option value="0.99">99%</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="ss-population-std">总体标准差 (σ)</label>
                        <input type="number" id="ss-population-std" value="1" step="0.1" min="0.01">
                    </div>
                </div>
                <button id="compute-sample-size" class="secondary">计算样本量</button>
                <div id="sample-size-result" class="stats-container hidden"></div>
            </div>
            
            <div id="confidence-results" class="hidden">
                <h3>分析结果</h3>
                <div class="stats-container">
                    <div id="confidence-summary" class="stats-grid"></div>
                </div>
                
                <div id="confidence-chart-container" class="chart-container">
                    <canvas id="confidence-chart"></canvas>
                </div>
                
                <div id="confidence-interpretation" class="card hidden">
                    <h3>结果解释</h3>
                    <div id="interpretation-text"></div>
                </div>
            </div>
        </div>
        
        <div id="analysis" class="tab-content hidden">
            <h2 data-i18n="dataAnalysis.title">数据分析</h2>
            
            <div class="form-group">
                <label data-i18n="dataAnalysis.inputMethod">数据输入方式</label>
                <div>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="distribution" checked> <span data-i18n="dataAnalysis.useDistribution">使用分布生成数据</span></label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="file" style="margin-left: 20px;"> <span data-i18n="dataAnalysis.uploadFile">上传CSV文件</span></label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="ai" style="margin-left: 20px;"> <span data-i18n="dataAnalysis.aiGenerate">AI生成数据</span></label>
                </div>
            </div>
            
            <div id="file-data-input" class="form-group hidden">
                <label for="file-upload" data-i18n="dataAnalysis.uploadCSV">上传CSV文件</label>
                <input type="file" id="file-upload" accept=".csv">
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;" data-i18n="dataAnalysis.csvHelp">支持CSV格式，每行一个数据或逗号分隔的数据。</p>
            </div>
            
            <div id="ai-data-input" class="form-group hidden">
                <label for="ai-data-description" data-i18n="dataAnalysis.aiDescription">数据描述</label>
                <textarea id="ai-data-description" rows="3" data-i18n-placeholder="dataAnalysis.aiDescriptionPlaceholder" placeholder="请描述您想要的数据特征，例如：生成1000个模拟股票价格数据，呈现一定的趋势和波动性"></textarea>
                <div class="form-row">
                    <div class="form-group" style="flex: 1; margin-right: 10px;">
                        <label for="ai-data-count" data-i18n="dataAnalysis.dataPointCount">数据点数量</label>
                        <input type="number" id="ai-data-count" min="100" max="10000" value="1000">
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="ai-data-seed" data-i18n="dataAnalysis.randomSeed">随机种子（可选）</label>
                        <input type="number" id="ai-data-seed" min="0" max="999999">
                    </div>
                </div>
                <button id="generate-ai-data" class="btn btn-primary" data-i18n="dataAnalysis.generateAIData">生成AI数据</button>
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;" data-i18n="dataAnalysis.aiDataHelp">基于您的描述，系统将生成符合特征的模拟数据。</p>
            </div>
            
            <div class="form-group">
                    <label for="chart-type" data-i18n="chart.type">图表类型</label>
                    <select id="chart-type">
                        <option value="histogram" data-i18n="chart.histogram">直方图</option>
                        <option value="bar" data-i18n="chart.bar">条形图</option>
                        <option value="scatter" data-i18n="chart.scatter">散点图</option>
                        <option value="line" data-i18n="chart.line">折线图</option>
                    </select>
                </div>
            
            <div class="button-group">
                <button id="analyze-data" data-i18n="dataAnalysis.analyzeData">分析数据</button>
                <button id="reset-analysis" class="secondary" data-i18n="dataAnalysis.resetAnalysis">重置分析</button>
            </div>
            
            <!-- 参数估计方法选择 -->
            <div id="parameter-estimation" class="form-group">
                <h3 data-i18n="parameterEstimation.title">参数估计</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="estimation-method" data-i18n="parameterEstimation.method">估计方法:</label>
                    <select id="estimation-method">
                        <option value="mom" data-i18n="parameterEstimation.mom">矩估计法(MOM)</option>
                        <option value="mle" data-i18n="parameterEstimation.mle">最大似然估计法(MLE)</option>
                    </select>
                    <button id="reestimate-btn" class="btn btn-secondary" data-i18n="parameterEstimation.reestimate">重新估计参数</button>
                </div>
            </div>
            
            <!-- 参数估计结果 -->
            <div id="parameter-estimation-results" class="stats-container hidden">
                <h3 data-i18n="parameterEstimation.results">参数估计结果</h3>
                <div id="estimation-results-grid" class="stats-grid"></div>
            </div>
            
            <div id="analysis-chart-container" class="chart-container hidden">
                <canvas id="analysis-chart"></canvas>
            </div>
        </div>
    </div>
    
    <!-- 进度条 -->
    <div id="generation-progress" class="progress-container hidden">
        <div class="progress-fill"></div>
        <div class="progress-text">正在生成数据...</div>
    </div>
    
    <script>
        // 统计应用程序对象
        const StatApp = {
            // 应用程序状态
            currentChart: null,
            generatedData: null,
            ai: null,
            
            // 初始化应用程序
            init() {
                console.log('初始化应用程序...');
                try {
                    this.setupEventListeners();
                    this.setupTabs();
                    this.setupDistributionTypeChange();
                    this.setupChartTypeChangeListener();
                    // 初始化AI集成
                    this.initAIIntegration();
                    // 设置参数估计按钮点击事件
                    this.setupParameterEstimationButton();
                    // 初始化假设检验功能
                    this.initHypothesisTesting();
                    // 初始化置信区间分析功能
                    this.initConfidenceIntervalEvents();
                    console.log('应用程序初始化完成');
                } catch (error) {
                    console.error('初始化应用时出错:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 设置参数估计按钮点击事件
            setupParameterEstimationButton() {
                const reestimateBtn = document.getElementById('reestimate-btn');
                if (reestimateBtn) {
                    reestimateBtn.addEventListener('click', () => {
                        this.estimateParameters();
                    });
                }
            },
            
            // 参数估计方法
            estimateParameters() {
                try {
                    if (!this.generatedData) {
                        alert(i18n.t('error.no.data.generated'));
                        return;
                    }
                    
                    const estimationMethod = document.getElementById('estimation-method').value;
                    const resultsGrid = document.getElementById('estimation-results-grid');
                    const resultsContainer = document.getElementById('parameter-estimation-results');
                    
                    if (resultsGrid) {
                        resultsGrid.innerHTML = '';
                    }
                    
                    // 计算基本统计量
                    const mean = this.generatedData.reduce((sum, val) => sum + val, 0) / this.generatedData.length;
                    const variance = this.generatedData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.generatedData.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // 根据选择的方法进行参数估计
                    let params;
                    let methodName;
                    
                    if (estimationMethod === 'mom') {
                        // 矩估计法
                        methodName = '矩估计法(MOM)';
                        // 正态分布的矩估计参数
                        params = {
                            '均值 (μ)': mean.toFixed(4),
                            '标准差 (σ)': stdDev.toFixed(4),
                            '方差 (σ²)': variance.toFixed(4)
                        };
                    } else if (estimationMethod === 'mle') {
                        // 最大似然估计法
                        methodName = '最大似然估计法(MLE)';
                        // 正态分布的MLE参数（对于正态分布，MLE与MOM结果相同）
                        params = {
                            '均值 (μ)': mean.toFixed(4),
                            '标准差 (σ)': stdDev.toFixed(4),
                            '方差 (σ²)': variance.toFixed(4)
                        };
                    }
                    
                    // 显示估计方法名称
                    const methodHeader = document.createElement('div');
                    methodHeader.className = 'estimation-method-header';
                    methodHeader.style.cssText = `
                        grid-column: 1 / -1;
                        font-weight: bold;
                        color: var(--primary-color);
                        margin-bottom: 10px;
                        text-align: center;
                        padding: 5px;
                        border-bottom: 2px solid var(--primary-color);
                    `;
                    methodHeader.textContent = i18n.t('estimated.parameters', { method: methodName });
                    
                    if (resultsGrid) {
                        resultsGrid.appendChild(methodHeader);
                    }
                    
                    // 创建参数估计结果卡片
                    Object.entries(params).forEach(([label, value]) => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        card.style.cssText = `
                            background-color: var(--card-background);
                            border: 1px solid var(--border-color);
                            border-radius: 6px;
                            padding: 12px;
                            box-shadow: var(--shadow);
                            text-align: center;
                        `;
                        
                        const labelElem = document.createElement('div');
                        labelElem.style.cssText = `
                            font-size: 14px;
                            color: var(--text-secondary);
                            margin-bottom: 5px;
                        `;
                        labelElem.textContent = label;
                        
                        const valueElem = document.createElement('div');
                        valueElem.style.cssText = `
                            font-size: 18px;
                            font-weight: bold;
                            color: var(--text-primary);
                        `;
                        valueElem.textContent = value;
                        
                        card.appendChild(labelElem);
                        card.appendChild(valueElem);
                        
                        if (resultsGrid) {
                            resultsGrid.appendChild(card);
                        }
                    });
                    
                    // 显示结果容器
                    if (resultsContainer) {
                        resultsContainer.classList.remove('hidden');
                    }
                    
                } catch (error) {
                    console.error('参数估计时出错:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 初始化AI集成
            initAIIntegration() {
                console.log('初始化AI集成');
                try {
                    // 创建DashScope集成实例
                    this.ai = new DashScopeIntegration();
                    // 尝试加载保存的API密钥
                    this.ai.loadApiKey();
                    
                    // 添加AI设置按钮
                    this.addAISettingsButton();
                } catch (error) {
                    console.warn('AI集成初始化失败:', error);
                    // 继续使用模拟AI作为后备
                }
            },
            
            // 添加AI设置按钮
            addAISettingsButton() {
                const aiInputContainer = document.getElementById('ai-data-input');
                if (aiInputContainer) {
                    const settingsButton = document.createElement('button');
                    settingsButton.id = 'ai-settings-button';
                    settingsButton.className = 'btn btn-outline-secondary';
                    settingsButton.style = 'margin-left: 10px;';
                    settingsButton.textContent = '🤖 AI设置';
                    settingsButton.onclick = () => this.showAISetup();
                    
                    const generateButton = document.getElementById('generate-ai-data');
                    if (generateButton) {
                        generateButton.parentNode.insertBefore(settingsButton, generateButton.nextSibling);
                    }
                }
            },
            
            // 显示AI设置模态框
            showAISetup() {
                // 创建模态框
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background-color: white;
                        border-radius: 8px;
                        padding: 20px;
                        width: 90%;
                        max-width: 500px;
                        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0;">🤖 AI 数据生成设置</h3>
                            <button id="close-modal" style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                                color: #666;
                            ">×</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">DashScope API 密钥</label>
                            <input type="password" id="api-key-input" style="
                                width: 100%;
                                padding: 10px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                                font-size: 14px;
                            " placeholder="输入您的 DashScope API 密钥">
                            <p style="font-size: 12px; color: #666; margin-top: 5px;">
                                从 <a href="https://dashscope.aliyun.com" target="_blank">阿里云 DashScope</a> 获取API密钥
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <button id="test-connection" style="
                                background-color: #4a6fa5;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">测试连接</button>
                            <button id="save-api-key" style="
                                background-color: #4caf50;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">保存 & 使用 AI</button>
                        </div>
                        
                        <div id="connection-status" style="
                            padding: 10px;
                            border-radius: 4px;
                            display: none;
                            font-size: 14px;
                        "></div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 关闭模态框
                document.getElementById('close-modal').onclick = () => {
                    document.body.removeChild(modal);
                };
                
                // 点击模态框外部关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
                
                // 测试连接
                document.getElementById('test-connection').onclick = async () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    const statusDiv = document.getElementById('connection-status');
                    
                    if (!apiKey) {
                        statusDiv.textContent = '请输入API密钥';
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                        statusDiv.style.display = 'block';
                        return;
                    }
                    
                    statusDiv.textContent = '正在测试连接...';
                    statusDiv.style.backgroundColor = '#e3f2fd';
                    statusDiv.style.color = '#1565c0';
                    statusDiv.style.display = 'block';
                    
                    try {
                        this.ai.setApiKey(apiKey);
                        const result = await this.ai.testConnection();
                        
                        if (result.success) {
                            statusDiv.textContent = '✅ 连接成功！';
                            statusDiv.style.backgroundColor = '#e8f5e9';
                            statusDiv.style.color = '#2e7d32';
                        } else {
                            statusDiv.textContent = `❌ 连接失败: ${result.message}`;
                            statusDiv.style.backgroundColor = '#ffebee';
                            statusDiv.style.color = '#c62828';
                        }
                    } catch (error) {
                        statusDiv.textContent = `❌ 错误: ${error.message}`;
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                    }
                };
                
                // 保存API密钥
                document.getElementById('save-api-key').onclick = () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    if (apiKey) {
                        this.ai.setApiKey(apiKey);
                        
                        const statusDiv = document.getElementById('connection-status');
                        statusDiv.textContent = '✅ API密钥已保存！';
                        statusDiv.style.backgroundColor = '#e8f5e9';
                        statusDiv.style.color = '#2e7d32';
                        statusDiv.style.display = 'block';
                        
                        // 延迟关闭模态框
                        setTimeout(() => {
                            document.body.removeChild(modal);
                        }, 1500);
                    }
                };
            },
            
            // 设置事件监听器
            setupEventListeners() {
                console.log('设置事件监听器...');
                try {
                    // 概率分布模拟相关事件
                    const generateDataBtn = document.getElementById('generate-data');
                    const clearDataBtn = document.getElementById('clear-data');
                    
                    console.log('生成数据按钮:', generateDataBtn);
                    if (generateDataBtn) {
                        generateDataBtn.addEventListener('click', () => {
                            console.log('点击生成数据按钮');
                            this.generateDistributionData();
                        });
                    }
                    
                    if (clearDataBtn) {
                        clearDataBtn.addEventListener('click', () => this.clearDistributionData());
                    }
                    
                    // 置信区间分析相关事件
                    const calculateConfidenceBtn = document.getElementById('calculate-confidence');
                    const generateConfidenceSampleBtn = document.getElementById('generate-confidence-sample');
                    
                    if (calculateConfidenceBtn) {
                        calculateConfidenceBtn.addEventListener('click', () => this.calculateConfidenceInterval());
                    }
                    
                    if (generateConfidenceSampleBtn) {
                        generateConfidenceSampleBtn.addEventListener('click', () => this.generateConfidenceSample());
                    }
                    
                    // 数据分析相关事件
                    const analyzeDataBtn = document.getElementById('analyze-data');
                    const resetAnalysisBtn = document.getElementById('reset-analysis');
                    const fileUpload = document.getElementById('file-upload');
                    
                    if (analyzeDataBtn) {
                        analyzeDataBtn.addEventListener('click', () => this.analyzeData());
                    }
                    
                    if (resetAnalysisBtn) {
                        resetAnalysisBtn.addEventListener('click', () => this.resetAnalysis());
                    }
                    
                    if (fileUpload) {
                        fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
                    }
                    
                    // 设置数据输入方式切换事件
                    document.querySelectorAll('input[name="data-input-method"]').forEach(radio => {
                        radio.addEventListener('change', () => this.switchDataInputMethod());
                    });
                    
                    // 设置AI生成数据按钮事件
                    const generateAIDataBtn = document.getElementById('generate-ai-data');
                    if (generateAIDataBtn) {
                        generateAIDataBtn.addEventListener('click', () => {
                            console.log('点击生成AI数据按钮');
                            this.generateAIData();
                        });
                    }
                    
                    console.log('事件监听器设置完成');
                } catch (error) {
                    console.error('设置事件监听器时出错:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 设置标签页切换
            setupTabs() {
                try {
                    const tabs = document.querySelectorAll('.tab');
                    tabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            const tabId = tab.getAttribute('data-tab');
                            
                            // 移除所有标签的活动状态
                            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            
                            // 隐藏所有内容
                            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                            const targetContent = document.getElementById(tabId);
                            if (targetContent) {
                                targetContent.classList.remove('hidden');
                            }
                        });
                    });
                } catch (error) {
                    console.error('设置标签页时出错:', error);
                }
            },
            
            // 设置分布类型变化事件
            setupDistributionTypeChange() {
                try {
                    const distributionType = document.getElementById('distribution-type');
                    const paramGroups = {
                        'normal': document.getElementById('normal-params'),
                        'binomial': document.getElementById('binomial-params'),
                        'poisson': document.getElementById('poisson-params'),
                        'uniform': document.getElementById('uniform-params'),
                        'exponential': document.getElementById('exponential-params')
                    };
                    
                    if (distributionType) {
                        distributionType.addEventListener('change', () => {
                            const selectedType = distributionType.value;
                            
                            // 隐藏所有参数组
                            for (const type in paramGroups) {
                                if (paramGroups[type]) {
                                    paramGroups[type].classList.add('hidden');
                                }
                            }
                            
                            // 显示选中的参数组
                            if (paramGroups[selectedType]) {
                                paramGroups[selectedType].classList.remove('hidden');
                            }
                        });
                    }
                } catch (error) {
                    console.error('设置分布类型变化时出错:', error);
                }
            },
            
            // 设置图表类型变化监听器
            setupChartTypeChangeListener() {
                try {
                    const chartTypeSelect = document.getElementById('chart-type');
                    
                    // 确保只添加一次事件监听器
                    if (chartTypeSelect && !chartTypeSelect.getAttribute('data-listener-added')) {
                        chartTypeSelect.addEventListener('change', () => {
                            // 当图表类型改变时，如果已经有分析结果，重新绘制图表
                            if (this.currentChart && this.generatedData) {
                                this.updateChart();
                            }
                        });
                        
                        // 标记已添加监听器
                        chartTypeSelect.setAttribute('data-listener-added', 'true');
                    }
                } catch (error) {
                    console.error('设置图表类型变化监听器时出错:', error);
                }
            },
            
            // 生成分布数据
            generateDistributionData() {
                console.log('开始生成分布数据...');
                try {
                    // 获取并验证元素存在性
                    const distributionTypeElement = document.getElementById('distribution-type');
                    const sampleSizeElement = document.getElementById('sample-size');
                    
                    if (!distributionTypeElement || !sampleSizeElement) {
                        throw new Error('找不到必要的DOM元素');
                    }
                    
                    const distributionType = distributionTypeElement.value;
                    const sampleSize = parseInt(sampleSizeElement.value);
                    
                    console.log('分布类型:', distributionType);
                    console.log('样本大小:', sampleSize);
                    
                    // 验证样本大小
                    if (isNaN(sampleSize) || sampleSize < 100 || sampleSize > 10000) {
                        alert(i18n.t('alert.invalid.sample.size'));
                        return;
                    }
                    
                    // 显示进度条
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = '正在生成数据...';
                    }
                    
                    // 模拟生成过程中的进度更新
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `正在生成数据... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // 根据不同分布类型生成数据 - 使用Promise确保异步操作的正确性
                    Promise.resolve().then(() => {
                        try {
                            let data = null;
                            
                            switch (distributionType) {
                                case 'normal':
                                    console.log('生成正态分布数据');
                                    data = this.generateNormalData(sampleSize);
                                    break;
                                case 'binomial':
                                    console.log('生成二项分布数据');
                                    data = this.generateBinomialData(sampleSize);
                                    break;
                                case 'poisson':
                                    console.log('生成泊松分布数据');
                                    data = this.generatePoissonData(sampleSize);
                                    break;
                                case 'uniform':
                                    console.log('生成均匀分布数据');
                                    data = this.generateUniformData(sampleSize);
                                    break;
                                case 'exponential':
                                    console.log('生成指数分布数据');
                                    data = this.generateExponentialData(sampleSize);
                                    break;
                                default:
                                    throw new Error('未知的分布类型');
                            }
                            
                            // 确保数据生成成功
                            if (!data || data.length === 0) {
                                throw new Error('数据生成失败，返回空数据');
                            }
                            
                            console.log('数据生成成功，长度:', data.length);
                            this.generatedData = data;
                            
                            // 更新进度条为100%
                            if (progressFill && progressText) {
                                progressFill.style.width = '100%';
                                progressText.textContent = '数据生成完成！';
                            }
                            
                            // 绘制图表
                            console.log('开始绘制图表');
                            this.plotDistributionChart(data, distributionType);
                            
                            // 计算并显示统计信息
                            console.log('开始计算统计信息');
                            this.calculateDistributionStats(data, distributionType);
                            
                            // 隐藏进度条
                            setTimeout(() => {
                                if (progressContainer) {
                                    progressContainer.classList.add('hidden');
                                }
                            }, 500);
                        } catch (error) {
                            console.error('生成数据时出错:', error);
                            alert(i18n.t('alert.failed.to.generate.data') + ': ' + error.message);
                            if (progressContainer) {
                                progressContainer.classList.add('hidden');
                            }
                        } finally {
                            clearInterval(interval);
                        }
                    });
                } catch (error) {
                    console.error('调用生成数据函数时出错:', error);
                    alert(i18n.t('alert.failed.to.generate.data') + ': ' + error.message);
                }
            },
            
            // 生成正态分布数据
            generateNormalData(sampleSize) {
                const mean = parseFloat(document.getElementById('normal-mean').value);
                const std = parseFloat(document.getElementById('normal-std').value);
                
                // 验证参数
                if (isNaN(mean) || isNaN(std) || std <= 0) {
                    throw new Error('无效的正态分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // Box-Muller 转换生成正态分布随机数
                    let u1, u2;
                    do {
                        u1 = Math.random();
                        u2 = Math.random();
                    } while (u1 <= Number.EPSILON);
                    
                    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    data.push(mean + z0 * std);
                }
                
                return data;
            },
            
            // 生成二项分布数据
            generateBinomialData(sampleSize) {
                const n = parseInt(document.getElementById('binomial-n').value);
                const p = parseFloat(document.getElementById('binomial-p').value);
                
                // 验证参数
                if (isNaN(n) || isNaN(p) || n <= 0 || p < 0 || p > 1) {
                    throw new Error('无效的二项分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let successes = 0;
                    for (let j = 0; j < n; j++) {
                        if (Math.random() < p) {
                            successes++;
                        }
                    }
                    data.push(successes);
                }
                
                return data;
            },
            
            // 生成泊松分布数据
            generatePoissonData(sampleSize) {
                const lambda = parseFloat(document.getElementById('poisson-lambda').value);
                
                // 验证参数
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('无效的泊松分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let k = 0;
                    let p = 1;
                    const L = Math.exp(-lambda);
                    
                    do {
                        k++;
                        p *= Math.random();
                    } while (p > L);
                    
                    data.push(k - 1);
                }
                
                return data;
            },
            
            // 生成均匀分布数据
            generateUniformData(sampleSize) {
                const min = parseFloat(document.getElementById('uniform-min').value);
                const max = parseFloat(document.getElementById('uniform-max').value);
                
                // 验证参数
                if (isNaN(min) || isNaN(max) || min >= max) {
                    throw new Error('无效的均匀分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    data.push(min + Math.random() * (max - min));
                }
                
                return data;
            },
            
            // 生成指数分布数据
            generateExponentialData(sampleSize) {
                const lambda = parseFloat(document.getElementById('exponential-lambda').value);
                
                // 验证参数
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('无效的指数分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // 逆变换法生成指数分布
                    const u = Math.random();
                    data.push(-Math.log(1 - u) / lambda);
                }
                
                return data;
            },
            
            // 绘制分布图表
            plotDistributionChart(data, distributionType) {
                console.log('绘制分布图表');
                try {
                    const chartElement = document.getElementById('distribution-chart');
                    const chartContainer = document.getElementById('distribution-chart-container');
                    
                    if (!chartElement || !chartContainer) {
                        throw new Error('找不到图表相关的DOM元素');
                    }
                    
                    const ctx = chartElement.getContext('2d');
                    
                    // 显示图表容器
                    chartContainer.classList.remove('hidden');
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        console.log('销毁旧图表');
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 计算直方图数据
                    const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    const binWidth = (max - min) / binCount;
                    
                    const bins = Array(binCount).fill(0);
                    const binLabels = [];
                    
                    for (let i = 0; i < binCount; i++) {
                        binLabels.push((min + i * binWidth).toFixed(2));
                    }
                    
                    data.forEach(value => {
                        if (value >= min && value <= max) {
                            const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                            bins[binIndex]++;
                        }
                    });
                    
                    // 归一化频率
                    const frequencies = bins.map(count => count / data.length);
                    
                    console.log('准备创建图表');
                    // 创建图表
                    this.currentChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: binLabels,
                            datasets: [{
                                label: `${this.getDistributionName(distributionType)}分布频率`,
                                data: frequencies,
                                backgroundColor: 'rgba(74, 111, 165, 0.7)',
                                borderColor: 'rgba(74, 111, 165, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: i18n.t('chart.x.axis.value')
                                    },
                                    ticks: {
                                        autoSkip: true,
                                        maxRotation: 0,
                                        callback: function(value, index, values) {
                                            // 只显示部分标签以避免拥挤
                                            return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                        }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: i18n.t('chart.y.axis.frequency')
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return value.toFixed(3);
                                        }
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${this.getDistributionName(distributionType)}分布直方图 (样本大小: ${data.length})`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.raw;
                                            const count = Math.round(value * data.length);
                                            return `频率: ${value.toFixed(4)} (计数: ${count})`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log('图表绘制完成');
                } catch (error) {
                    console.error('绘制图表时出错:', error);
                    alert(i18n.t('alert.failed.to.create.chart') + ': ' + error.message);
                }
            },
            
            // 计算分布统计信息
            calculateDistributionStats(data, distributionType) {
                try {
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (statsContainer) {
                        statsContainer.innerHTML = '';
                        statsContainer.classList.remove('hidden');
                    }
                    
                    // 计算统计量
                    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
                    const sortedData = [...data].sort((a, b) => a - b);
                    const median = sortedData.length % 2 === 0
                        ? (sortedData[sortedData.length / 2 - 1] + sortedData[sortedData.length / 2]) / 2
                        : sortedData[Math.floor(sortedData.length / 2)];
                    
                    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
                    const std = Math.sqrt(variance);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    
                    // 计算四分位数
                    const q1Index = Math.floor(sortedData.length * 0.25);
                    const q3Index = Math.floor(sortedData.length * 0.75);
                    const q1 = sortedData[q1Index];
                    const q3 = sortedData[q3Index];
                    const iqr = q3 - q1;
                    
                    // 创建统计卡片
                    const stats = [
                        { label: i18n.t('stats.mean'), value: mean.toFixed(4) },
                        { label: i18n.t('stats.median'), value: median.toFixed(4) },
                        { label: i18n.t('stats.std.dev'), value: std.toFixed(4) },
                        { label: i18n.t('stats.variance'), value: variance.toFixed(4) },
                        { label: i18n.t('stats.min'), value: min.toFixed(4) },
                        { label: i18n.t('stats.max'), value: max.toFixed(4) },
                        { label: i18n.t('stats.q1'), value: q1.toFixed(4) },
                        { label: i18n.t('stats.q3'), value: q3.toFixed(4) },
                        { label: i18n.t('stats.iqr'), value: iqr.toFixed(4) }
                    ];
                    
                    // 添加统计卡片到容器
                    stats.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        
                        const label = document.createElement('div');
                        label.className = 'stat-label';
                        label.textContent = stat.label;
                        
                        const value = document.createElement('div');
                        value.className = 'stat-value';
                        value.textContent = stat.value;
                        
                        card.appendChild(label);
                        card.appendChild(value);
                        
                        if (statsContainer) {
                            statsContainer.appendChild(card);
                        }
                    });
                } catch (error) {
                    console.error('计算统计信息时出错:', error);
                }
            },
            
            // 清除分布数据
            clearDistributionData() {
                try {
                    // 销毁图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 隐藏图表和统计信息
                    const chartContainer = document.getElementById('distribution-chart-container');
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    if (statsContainer) {
                        statsContainer.classList.add('hidden');
                    }
                    
                    // 清除数据
                    this.generatedData = null;
                } catch (error) {
                    console.error('清除数据时出错:', error);
                }
            },
            
            // 初始化置信区间分析事件监听器
            initConfidenceIntervalEvents() {
                // 数据输入方式切换
                const dataMethods = document.querySelectorAll('input[name="confidence-data-method"]');
                dataMethods.forEach(method => {
                    method.addEventListener('change', () => this.toggleConfidenceDataSections());
                });
                
                // 检验方法切换
                document.getElementById('confidence-test-type').addEventListener('change', () => {
                    const stdSection = document.getElementById('sample-std-section');
                    const testType = document.getElementById('confidence-test-type').value;
                    stdSection.classList.toggle('hidden', testType !== 'z-test');
                });
                
                // 计算样本量按钮
                document.getElementById('calculate-sample-size').addEventListener('click', () => {
                    document.getElementById('sample-size-calculator').classList.toggle('hidden');
                });
                
                // 执行样本量计算
                document.getElementById('compute-sample-size').addEventListener('click', () => {
                    this.calculateRequiredSampleSize();
                });
                
                // 清除结果按钮
                document.getElementById('clear-confidence-results').addEventListener('click', () => {
                    this.clearConfidenceResults();
                });
                
                // 计算置信区间按钮
                document.getElementById('calculate-confidence').addEventListener('click', () => {
                    this.calculateConfidenceInterval();
                });
                
                // 生成样本并分析按钮
                document.getElementById('generate-confidence-sample').addEventListener('click', () => {
                    this.generateConfidenceSample();
                });
                
                // 初始化显示正确的部分
                this.toggleConfidenceDataSections();
            },
            
            // 切换置信区间数据输入部分
            toggleConfidenceDataSections() {
                const method = document.querySelector('input[name="confidence-data-method"]:checked').value;
                
                document.getElementById('sample-data-section').classList.toggle('hidden', method !== 'sample');
                document.getElementById('population-data-section').classList.toggle('hidden', method !== 'population');
                document.getElementById('generate-data-section').classList.toggle('hidden', method !== 'generate');
                
                // 如果是Z检验，显示总体标准差输入框
                const testType = document.getElementById('confidence-test-type')?.value;
                const stdSection = document.getElementById('sample-std-section');
                if (stdSection && testType) {
                    stdSection.classList.toggle('hidden', testType !== 'z-test');
                }
            },
            
            // 计算置信区间
            calculateConfidenceInterval() {
                try {
                    const method = document.querySelector('input[name="confidence-data-method"]:checked').value;
                    let result;
                    
                    switch (method) {
                        case 'sample':
                            result = this.calculateConfidenceFromSample();
                            break;
                        case 'population':
                            result = this.calculateConfidenceFromParameters();
                            break;
                        default:
                            alert(i18n.t('alert.please.select.valid.data.method'));
                            return;
                    }
                    
                    if (result) {
                        // 保存结果到全局对象，供语言切换时使用
                        window.confidenceIntervalModule.lastResult = result;
                        
                        this.displayConfidenceResults(result);
                        this.plotConfidenceIntervalChart(result);
                        this.generateInterpretation(result);
                    }
                } catch (error) {
                    console.error('计算置信区间时出错:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 从样本数据计算置信区间
            calculateConfidenceFromSample() {
                const sampleDataInput = document.getElementById('sample-data').value.trim();
                if (!sampleDataInput) {
                    alert(i18n.t('alert.please.enter.sample.data'));
                    return null;
                }
                
                // 解析样本数据
                const sampleData = sampleDataInput.split(',').map(val => parseFloat(val.trim())).filter(val => !isNaN(val));
                
                if (sampleData.length === 0) {
                    alert(i18n.t('alert.could.not.parse.sample.data'));
                    return null;
                }
                
                const testType = document.getElementById('confidence-test-type').value;
                const sampleSize = sampleData.length;
                
                // 计算样本统计量
                const sampleMean = sampleData.reduce((sum, val) => sum + val, 0) / sampleSize;
                const sampleVariance = sampleData.reduce((sum, val) => sum + Math.pow(val - sampleMean, 2), 0) / (sampleSize - 1);
                const sampleStd = Math.sqrt(sampleVariance);
                
                // 获取置信水平
                const confidenceLevel = parseFloat(document.getElementById('confidence-level')?.value || 0.95);
                
                let criticalValue, standardError, marginOfError, lowerBound, upperBound, method;
                
                if (testType === 'z-test') {
                    // Z检验：使用用户提供的总体标准差
                    const populationStd = parseFloat(document.getElementById('sample-population-std').value);
                    if (isNaN(populationStd) || populationStd <= 0) {
                        alert(i18n.t('alert.invalid.population.std'));
                        return null;
                    }
                    
                    criticalValue = this.getZScore(confidenceLevel);
                    standardError = populationStd / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = `Z检验 (使用总体标准差 σ=${populationStd})`;
                    
                    return {
                        method,
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        populationStd,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        confidenceInterval: `[${lowerBound.toFixed(4)}, ${upperBound.toFixed(4)}]`,
                        testType: 'z-test',
                        data: sampleData
                    };
                } else {
                    // T检验：使用样本标准差
                    const degreesOfFreedom = sampleSize - 1;
                    criticalValue = this.getTScore(confidenceLevel, degreesOfFreedom);
                    standardError = sampleStd / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = `T检验 (自由度=${degreesOfFreedom})`;
                    
                    return {
                        method,
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        degreesOfFreedom: degreesOfFreedom,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        confidenceInterval: `[${lowerBound.toFixed(4)}, ${upperBound.toFixed(4)}]`,
                        testType: 't-test',
                        data: sampleData
                    };
                }
            },
            
            // 从参数计算置信区间
            calculateConfidenceFromParameters() {
                const confidenceLevel = parseFloat(document.getElementById('confidence-level').value);
                const sampleMean = parseFloat(document.getElementById('population-mean').value);
                const stdValue = parseFloat(document.getElementById('population-std').value);
                const sampleSize = parseInt(document.getElementById('sample-size-confidence').value);
                const stdType = document.getElementById('std-type').value;
                
                // 验证参数
                if (isNaN(confidenceLevel) || isNaN(sampleMean) || isNaN(stdValue) || isNaN(sampleSize) || 
                    stdValue <= 0 || sampleSize <= 0) {
                    alert(i18n.t('alert.invalid.parameters'));
                    return null;
                }
                
                let criticalValue, standardError, marginOfError, lowerBound, upperBound, method;
                
                // 选择检验方法：
                // 1. 如果已知总体标准差，使用Z检验
                // 2. 如果未知总体标准差但样本量足够大(n≥30)，可以使用Z检验近似
                // 3. 如果未知总体标准差且样本量小(n<30)，使用T检验
                if (stdType === 'population') {
                    // Z检验：已知总体标准差
                    criticalValue = this.getZScore(confidenceLevel);
                    standardError = stdValue / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = `Z检验 (已知总体标准差 σ=${stdValue})`;
                } else if (sampleSize >= 30) {
                    // Z检验：未知总体标准差但大样本
                    criticalValue = this.getZScore(confidenceLevel);
                    standardError = stdValue / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = `Z检验 (大样本近似，s=${stdValue})`;
                } else {
                    // T检验：小样本且未知总体标准差
                    const degreesOfFreedom = sampleSize - 1;
                    criticalValue = this.getTScore(confidenceLevel, degreesOfFreedom);
                    standardError = stdValue / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = `T检验 (小样本，自由度=${degreesOfFreedom})`;
                }
                
                // 准备返回对象，确保与其他函数的格式一致
                const result = {
                    method,
                    confidenceLevel,
                    sampleSize,
                    sampleMean,
                    criticalValue,
                    standardError,
                    marginOfError,
                    lowerBound,
                    upperBound,
                    confidenceInterval: `[${lowerBound.toFixed(4)}, ${upperBound.toFixed(4)}]`,
                    testType: stdType === 'population' || sampleSize >= 30 ? 'z-test' : 't-test',
                    stdType: stdType
                };
                
                // 根据标准差类型添加相应的字段
                if (stdType === 'population') {
                    result.populationStd = stdValue;
                    result.degreesOfFreedom = null; // Z检验不涉及自由度
                } else {
                    result.sampleStd = stdValue;
                    // 只有在使用T检验时才添加自由度
                    if (sampleSize < 30) {
                        result.degreesOfFreedom = sampleSize - 1;
                    } else {
                        result.degreesOfFreedom = null;
                    }
                }
                
                return result;
            },
            
            // 生成置信区间样本并分析
            generateConfidenceSample() {
                try {
                    const distributionType = document.getElementById('generate-distribution').value;
                    const mean = parseFloat(document.getElementById('generate-mean').value);
                    const std = parseFloat(document.getElementById('generate-std').value);
                    const sampleSize = parseInt(document.getElementById('generate-sample-size').value);
                    const confidenceLevel = parseFloat(document.getElementById('generate-confidence-level').value);
                    
                    // 验证参数
                    if (isNaN(mean) || isNaN(std) || isNaN(sampleSize) || isNaN(confidenceLevel) || 
                        std <= 0 || sampleSize <= 0) {
                        alert(i18n.t('alert.invalid.parameters'));
                        return;
                    }
                    
                    // 生成样本数据
                    const sampleData = this.generateConfidenceSampleData(distributionType, sampleSize, mean, std);
                    
                    // 计算样本统计量
                    const sampleMean = sampleData.reduce((sum, val) => sum + val, 0) / sampleSize;
                    const sampleVariance = sampleData.reduce((sum, val) => sum + Math.pow(val - sampleMean, 2), 0) / (sampleSize - 1);
                    const sampleStd = Math.sqrt(sampleVariance);
                    
                    // 选择检验方法
                    // 在模拟场景中，我们实际上知道总体标准差，因此应该使用Z检验
                    // 但同时计算T检验结果作为参考，因为在实际数据分析中通常未知总体标准差
                    
                    // Z检验（使用已知的总体标准差）
                    const zCriticalValue = this.getZScore(confidenceLevel);
                    const zStandardError = std / Math.sqrt(sampleSize); // 使用已知的总体标准差
                    const zMarginOfError = zCriticalValue * zStandardError;
                    const zLowerBound = sampleMean - zMarginOfError;
                    const zUpperBound = sampleMean + zMarginOfError;
                    const zMethod = `Z检验 (已知总体标准差 σ=${std})`;
                    
                    // T检验（使用样本标准差）
                    const degreesOfFreedom = sampleSize - 1;
                    const tCriticalValue = this.getTScore(confidenceLevel, degreesOfFreedom);
                    const tStandardError = sampleStd / Math.sqrt(sampleSize);
                    const tMarginOfError = tCriticalValue * tStandardError;
                    const tLowerBound = sampleMean - tMarginOfError;
                    const tUpperBound = sampleMean + tMarginOfError;
                    const tMethod = `T检验 (自由度=${degreesOfFreedom})`;
                    
                    // 由于我们在模拟中知道总体标准差，默认使用Z检验结果
                    let criticalValue = zCriticalValue;
                    let standardError = zStandardError;
                    let marginOfError = zMarginOfError;
                    let lowerBound = zLowerBound;
                    let upperBound = zUpperBound;
                    let method = zMethod;
                    
                    const result = {
                        method,
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        populationMean: mean,
                        populationStd: std,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        testType: 'z-test', // 因为我们使用已知总体标准差，应该是z-test
                        degreesOfFreedom: degreesOfFreedom,
                        data: sampleData,
                        distributionType,
                        
                        // 额外提供T检验结果作为参考
                        tMethod,
                        tCriticalValue,
                        tStandardError,
                        tMarginOfError,
                        tLowerBound,
                        tUpperBound
                    };
                    
                    this.displayConfidenceResults(result);
                    this.plotConfidenceIntervalChart(result);
                    this.generateInterpretation(result);
                } catch (error) {
                    console.error('生成置信区间样本时出错:', error);
                    alert(i18n.t('alert.failed.to.generate.sample') + ': ' + error.message);
                }
            },
            
            // 计算所需样本量
            calculateRequiredSampleSize() {
                try {
                    const marginError = parseFloat(document.getElementById('margin-error').value);
                    const confidenceLevel = parseFloat(document.getElementById('ss-confidence-level').value);
                    const populationStd = parseFloat(document.getElementById('ss-population-std').value);
                    
                    // 验证参数
                    if (isNaN(marginError) || isNaN(confidenceLevel) || isNaN(populationStd) || 
                        marginError <= 0 || populationStd <= 0 || confidenceLevel <= 0 || confidenceLevel >= 1) {
                        alert(i18n.t('alert.please.enter.valid.parameters'));
                        return;
                    }
                    
                    // 保存参数到全局对象，供语言切换时使用
                    window.confidenceIntervalModule.lastSampleSizeParams = { marginError, confidenceLevel, populationStd };
                    
                    // 计算Z分数
                    const zScore = this.getZScore(confidenceLevel);
                    
                    // 计算样本量
                    const sampleSize = Math.ceil(Math.pow((zScore * populationStd) / marginError, 2));
                    
                    // 显示结果
                    const resultContainer = document.getElementById('sample-size-result');
                    resultContainer.innerHTML = '';
                    resultContainer.classList.remove('hidden');
                    
                    const stats = [
                        { label: i18n.t('stats.required.sample.size'), value: sampleSize },
                        { label: i18n.t('confidence.level'), value: `${confidenceLevel * 100}%` },
                        { label: i18n.t('stats.margin.error'), value: marginError.toFixed(4) },
                        { label: i18n.t('stats.population.std'), value: populationStd.toFixed(4) },
                        { label: i18n.t('stats.z.score'), value: zScore.toFixed(4) }
                    ];
                    
                    stats.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        
                        const label = document.createElement('div');
                        label.className = 'stat-label';
                        label.textContent = stat.label;
                        
                        const value = document.createElement('div');
                        value.className = 'stat-value';
                        value.textContent = stat.value;
                        
                        card.appendChild(label);
                        card.appendChild(value);
                        resultContainer.appendChild(card);
                    });
                    
                    // 添加解释文本
                    const explanation = document.createElement('div');
                    explanation.className = 'help-text';
                    explanation.style.marginTop = '15px';
                    explanation.innerHTML = `
                        <p><strong>${i18n.t('sample.size.explanation.title')}：</strong>${i18n.t('sample.size.explanation', {
                            confidenceLevel: confidenceLevel * 100,
                            marginError: marginError,
                            populationStd: populationStd,
                            sampleSize: sampleSize
                        })}</p>
                    `;
                    resultContainer.appendChild(explanation);
                } catch (error) {
                    console.error('计算样本量时出错:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 重新计算样本量（语言切换时使用）
            recalculateSampleSize() {
                // 如果有保存的样本量参数，则重新计算
                if (window.confidenceIntervalModule.lastSampleSizeParams) {
                    const { marginError, confidenceLevel, populationStd } = window.confidenceIntervalModule.lastSampleSizeParams;
                    
                    // 恢复表单值
                    document.getElementById('margin-error').value = marginError;
                    document.getElementById('ss-confidence-level').value = confidenceLevel;
                    document.getElementById('ss-population-std').value = populationStd;
                    
                    // 重新计算
                    this.calculateRequiredSampleSize();
                }
            },
            
            // 显示置信区间分析结果
            displayConfidenceResults(result) {
                const resultsContainer = document.getElementById('confidence-results');
                const summaryContainer = document.getElementById('confidence-summary');
                
                // 清空并显示容器
                summaryContainer.innerHTML = '';
                resultsContainer.classList.remove('hidden');
                
                // 准备统计数据
                const stats = [
                    { label: i18n.t('stats.analysis.method'), value: result.method },
                    { label: i18n.t('confidence.level'), value: `${result.confidenceLevel * 100}%` },
                    { label: i18n.t('stats.sample.size'), value: result.sampleSize },
                    { label: i18n.t('stats.sample.mean'), value: result.sampleMean.toFixed(4) }
                ];
                
                // 添加标准差信息
                if (result.populationStd) {
                    stats.push({ label: i18n.t('stats.population.std'), value: result.populationStd.toFixed(4) });
                }
                if (result.sampleStd) {
                    stats.push({ label: i18n.t('stats.sample.std'), value: result.sampleStd.toFixed(4) });
                }
                
                // 添加自由度（T检验时）
                if (result.degreesOfFreedom !== null) {
                    stats.push({ label: i18n.t('stats.degrees.freedom'), value: result.degreesOfFreedom });
                }
                
                // 添加临界值、标准误和边际误差
                stats.push(
                    { label: i18n.t('stats.critical.value'), value: result.criticalValue.toFixed(4) },
                    { label: i18n.t('stats.standard.error'), value: result.standardError.toFixed(4) },
                    { label: i18n.t('stats.margin.error'), value: result.marginOfError.toFixed(4) },
                    { label: i18n.t('stats.confidence.interval.lower'), value: result.lowerBound.toFixed(4) },
                    { label: i18n.t('stats.confidence.interval.upper'), value: result.upperBound.toFixed(4) },
                    { label: i18n.t('stats.confidence.interval'), value: `[${result.lowerBound.toFixed(4)}, ${result.upperBound.toFixed(4)}]` }
                );
                
                // 创建统计卡片
                stats.forEach(stat => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    
                    const label = document.createElement('div');
                    label.className = 'stat-label';
                    label.textContent = stat.label;
                    
                    const value = document.createElement('div');
                    value.className = 'stat-value';
                    value.textContent = stat.value;
                    
                    card.appendChild(label);
                    card.appendChild(value);
                    summaryContainer.appendChild(card);
                });
                
                // 如果有总体均值，添加额外信息
                if (result.populationMean !== undefined) {
                    const containsTrueMean = result.lowerBound <= result.populationMean && result.populationMean <= result.upperBound;
                    const meanInfoCard = document.createElement('div');
                    meanInfoCard.className = `stat-card ${containsTrueMean ? 'highlight-accept' : 'highlight-reject'}`;
                    meanInfoCard.innerHTML = `
                        <div class="stat-label">${i18n.t('stats.contains.true.mean')}</div>
                        <div class="stat-value">${containsTrueMean ? i18n.t('stats.contains.true.mean.yes') : i18n.t('stats.contains.true.mean.no')}</div>
                        <div class="help-text">${i18n.t('stats.actual.population.mean')}: ${result.populationMean.toFixed(4)}</div>
                    `;
                    summaryContainer.appendChild(meanInfoCard);
                }
                
                // 如果存在T检验参考结果，则显示它们
                if (result.tMethod) {
                    const tSection = document.createElement('div');
                    tSection.className = 't-test-reference';
                    tSection.style.marginTop = '20px';
                    tSection.style.padding = '15px';
                    tSection.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                    tSection.style.borderLeft = '4px solid #007bff';
                    
                    let tHtml = `<h4>${i18n.t('stats.t.test.reference')}</h4><div class="stats-grid">`;
                    const tStats = [
                        { label: i18n.t('stats.method'), value: result.tMethod },
                        { label: i18n.t('stats.t.critical.value'), value: result.tCriticalValue.toFixed(4) },
                        { label: i18n.t('stats.t.standard.error'), value: result.tStandardError.toFixed(4) },
                        { label: i18n.t('stats.t.margin.error'), value: result.tMarginOfError.toFixed(4) },
                        { label: i18n.t('stats.t.confidence.interval'), value: `[${result.tLowerBound.toFixed(4)}, ${result.tUpperBound.toFixed(4)}]` }
                    ];
                    
                    tStats.forEach(stat => {
                        tHtml += `
                            <div class="stat-card">
                                <div class="stat-label">${stat.label}:</div>
                                <div class="stat-value">${stat.value}</div>
                            </div>
                        `;
                    });
                    
                    tHtml += '</div>';
                    tSection.innerHTML = tHtml;
                    summaryContainer.appendChild(tSection);
                }
                
                // 显示图表容器
                const chartContainer = document.getElementById('confidence-chart-container');
                chartContainer.classList.remove('hidden');
                
                // 显示解释容器
                const interpretationContainer = document.getElementById('confidence-interpretation');
                interpretationContainer.classList.remove('hidden');
            },
            
            // 生成结果解释
            generateInterpretation(result) {
                const interpretationContainer = document.getElementById('confidence-interpretation');
                const interpretationText = document.getElementById('interpretation-text');
                
                // 计算效应量（Cohen's d）
                let effectSize = null;
                if (result.sampleMean && result.sampleStd) {
                    effectSize = Math.abs(result.sampleMean) / result.sampleStd;
                }
                
                let text = `
                    <p><strong>${i18n.t('confidence.interpretation.statistical')}：</strong></p>
                    <p>${i18n.t('confidence.interpretation.confident', {
                        confidenceLevel: result.confidenceLevel * 100,
                        lowerBound: result.lowerBound.toFixed(4),
                        upperBound: result.upperBound.toFixed(4)
                    })}</p>
                    
                    <p><strong>${i18n.t('confidence.interpretation.methodological')}：</strong></p>
                    <ul>
                        <li>${i18n.t('confidence.interpretation.using', { method: result.method })}</li>
                        <li>${i18n.t('confidence.interpretation.based.on', { sampleSize: result.sampleSize })}</li>
                        <li>${i18n.t('confidence.interpretation.margin.error', { marginError: result.marginOfError.toFixed(4) })}</li>
                    </ul>
                `;
                
                // 添加效应量解释（如果可用）
                if (effectSize !== null) {
                    let effectSizeKey = 'stats.effect.size.smallest';
                    if (effectSize < 0.2) effectSizeKey = 'stats.effect.size.smallest';
                    else if (effectSize < 0.5) effectSizeKey = 'stats.effect.size.small';
                    else if (effectSize < 0.8) effectSizeKey = 'stats.effect.size.medium';
                    else effectSizeKey = 'stats.effect.size.large';
                    
                    text += `
                        <p><strong>${i18n.t('stats.effect.size.analysis')}：</strong></p>
                        <p>${i18n.t('stats.cohens.d')} = ${effectSize.toFixed(4)}（${i18n.t(effectSizeKey)}）</p>
                    `;
                }
                
                // 添加实际应用建议
                text += `
                    <p><strong>${i18n.t('stats.practical.application')}：</strong></p>
                    <ul>
                        <li>${i18n.t('stats.increase.sample.size')}</li>
                        <li>${i18n.t('stats.current.margin.error')} ${result.marginOfError.toFixed(4)}，${i18n.t('stats.adjust.confidence.level')}</li>
                        <li>${result.confidenceLevel === 0.95 ? i18n.t('stats.common.confidence.level') : 
                          i18n.t('stats.selected.confidence.level', { confidenceLevel: result.confidenceLevel * 100 })}
                        </li>
                    </ul>
                `;
                
                interpretationText.innerHTML = text;
                interpretationContainer.classList.remove('hidden');
            },
            
            // 获取Z分数（支持更精确的计算）
            getZScore(confidenceLevel) {
                // 使用逆正态分布近似 - 对于置信区间，我们需要使用1-α/2
                const alpha = 1 - confidenceLevel;
                const zScore = Math.sqrt(2) * this.erfInv(1 - alpha / 2);
                return Math.abs(zScore);
            },
            
            // 获取T分数（更准确的计算）
            getTScore(confidenceLevel, degreesOfFreedom) {
                // 确保自由度为正整数
                degreesOfFreedom = Math.max(1, Math.floor(degreesOfFreedom));
                
                // 对于大自由度，使用Z分数近似
                if (degreesOfFreedom >= 100) {
                    return this.getZScore(confidenceLevel);
                }
                
                // 完善的T分布临界值表（双侧检验）
                const tTable = {
                    0.90: {
                        1: 6.314, 2: 2.920, 3: 2.353, 4: 2.132, 5: 2.015, 6: 1.943, 7: 1.895, 8: 1.860, 9: 1.833,
                        10: 1.812, 15: 1.753, 20: 1.725, 30: 1.697, 40: 1.684, 50: 1.676, 60: 1.671, 70: 1.667, 80: 1.664,
                        90: 1.662, 99: 1.660
                    },
                    0.95: {
                        1: 12.706, 2: 4.303, 3: 3.182, 4: 2.776, 5: 2.571, 6: 2.447, 7: 2.365, 8: 2.306, 9: 2.262,
                        10: 2.228, 15: 2.131, 20: 2.086, 30: 2.042, 40: 2.021, 50: 2.009, 60: 2.000, 70: 1.994, 80: 1.990,
                        90: 1.987, 99: 1.984
                    },
                    0.99: {
                        1: 63.657, 2: 9.925, 3: 5.841, 4: 4.604, 5: 4.032, 6: 3.707, 7: 3.499, 8: 3.355, 9: 3.250,
                        10: 3.169, 15: 2.947, 20: 2.845, 30: 2.750, 40: 2.704, 50: 2.678, 60: 2.660, 70: 2.648, 80: 2.639,
                        90: 2.632, 99: 2.626
                    }
                };
                
                // 查找最接近的自由度
                if (tTable[confidenceLevel] && tTable[confidenceLevel][degreesOfFreedom]) {
                    return tTable[confidenceLevel][degreesOfFreedom];
                }
                
                // 线性插值或使用Z分数近似
                const cl = confidenceLevel;
                const df = degreesOfFreedom;
                
                // 如果自由度大于表中最大值，使用Z分数近似
                if (df > 99) {
                    return this.getZScore(confidenceLevel);
                }
                
                // 查找最接近的自由度值
                let lowerDf = Math.floor(df);
                let upperDf = Math.ceil(df);
                
                if (lowerDf < 1) lowerDf = 1;
                if (upperDf > 99) upperDf = 99;
                
                if (tTable[cl] && tTable[cl][lowerDf] && tTable[cl][upperDf]) {
                    // 线性插值
                    const lowerT = tTable[cl][lowerDf];
                    const upperT = tTable[cl][upperDf];
                    return lowerT + (upperT - lowerT) * (df - lowerDf);
                }
                
                // 默认使用Z分数
                return this.getZScore(confidenceLevel);
            },
            
            // 误差函数逆函数（用于更精确的Z分数计算）
            erfInv(x) {
                // 近似实现误差函数的逆函数
                const a = 0.14001228868666e0;
                const b = 0.44814322062058e0;
                const c = 0.96061387286725e-1;
                const d = 0.49267329197003e-1;
                const e = 0.37540566805404e-1;
                
                const y = Math.log(1 - x * x);
                const z = Math.sqrt(-y - 1.26551223 + y * (a + y * (b + y * (c + y * (d + y * e)))));
                
                return x >= 0 ? z : -z;
            },
            
            // 绘制置信区间图表
            plotConfidenceIntervalChart(result) {
                try {
                    const ctx = document.getElementById('confidence-chart').getContext('2d');
                    const chartContainer = document.getElementById('confidence-chart-container');
                    
                    // 显示图表容器
                    chartContainer.classList.remove('hidden');
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    // 计算图表数据范围 - 确保能容纳所有显示的置信区间
                    const center = result.sampleMean;
                    
                    // 找出最小的下界和最大的上界（包括T检验结果）
                    let minLower = result.lowerBound;
                    let maxUpper = result.upperBound;
                    
                    if (result.tLowerBound !== undefined) {
                        minLower = Math.min(minLower, result.tLowerBound);
                        maxUpper = Math.max(maxUpper, result.tUpperBound);
                    }
                    
                    // 计算合适的范围
                    const rangeFromBounds = (maxUpper - minLower) * 1.5;
                    const rangeFromCenter = Math.max(result.marginOfError * 3, 0.01);
                    const range = Math.max(rangeFromBounds, rangeFromCenter);
                    
                    const min = center - range;
                    const max = center + range;
                    
                    // 创建基础数据点
                    const pointCount = 100;
                    const xLabels = [];
                    const normalData = [];
                    
                    for (let i = 0; i < pointCount; i++) {
                        const x = min + (max - min) * i / (pointCount - 1);
                        xLabels.push(x.toFixed(2));
                        
                        // 计算正态分布概率密度
                        const std = result.testType === 'z-test' ? 
                            (result.populationStd ? result.populationStd / Math.sqrt(result.sampleSize) : result.sampleStd / Math.sqrt(result.sampleSize)) : 
                            (result.sampleStd / Math.sqrt(result.sampleSize));
                        
                        const normalValue = (1 / (std * Math.sqrt(2 * Math.PI))) * 
                            Math.exp(-0.5 * Math.pow((x - center) / std, 2));
                        normalData.push(normalValue);
                    }
                    
                    // 创建置信区间区域数据
                    const ciRange = [];
                    const fillData = [];
                    const tFillData = []; // T检验的填充数据
                    
                    for (let i = 0; i < pointCount; i++) {
                        const x = min + (max - min) * i / (pointCount - 1);
                        ciRange.push(x);
                        
                        // 主置信区间（Z检验）内的值设为对应正态分布值，否则设为0
                        const std = result.testType === 'z-test' ? 
                            (result.populationStd ? result.populationStd / Math.sqrt(result.sampleSize) : result.sampleStd / Math.sqrt(result.sampleSize)) : 
                            (result.sampleStd / Math.sqrt(result.sampleSize));
                        const normalValue = (1 / (std * Math.sqrt(2 * Math.PI))) * 
                            Math.exp(-0.5 * Math.pow((x - center) / std, 2));
                        
                        if (x >= result.lowerBound && x <= result.upperBound) {
                            fillData.push(normalValue);
                        } else {
                            fillData.push(0);
                        }
                        
                        // T检验置信区间填充（如果有T检验结果）
                        if (result.tLowerBound !== undefined) {
                            if (x >= result.tLowerBound && x <= result.tUpperBound) {
                                tFillData.push(normalValue);
                            } else {
                                tFillData.push(0);
                            }
                        }
                    }
                    
                    // 创建图表数据集
                    const datasets = [
                        // 正态分布曲线
                        {
                            label: i18n.t('chart.sampling.distribution'),
                            data: normalData,
                            borderColor: 'rgba(74, 111, 165, 0.8)',
                            backgroundColor: 'rgba(74, 111, 165, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        },
                        // 主置信区间填充
                        {
                            label: `${result.confidenceLevel * 100}% ${result.testType === 'z-test' ? i18n.t('z.test') : i18n.t('t.test')} ${i18n.t('stats.confidence.interval')}`,
                            data: fillData,
                            backgroundColor: 'rgba(74, 111, 165, 0.3)',
                            borderColor: 'transparent',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        // 样本均值点
                        {
                            label: i18n.t('chart.sample.mean'),
                            data: [null, null, null, normalData[Math.floor(pointCount/2)], null, null, null],
                            backgroundColor: 'rgba(249, 160, 63, 1)',
                            borderColor: 'rgba(249, 160, 63, 1)',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ];
                    
                    // 如果有T检验参考结果，添加到图表
                            if (result.tLowerBound !== undefined) {
                                datasets.splice(2, 0, { // 插入到样本均值点之前
                                    label: `${result.confidenceLevel * 100}% ${i18n.t('t.test')} ${i18n.t('stats.t.test.reference')}`,
                                    data: tFillData,
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    borderColor: 'transparent',
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 0
                                });
                            }
                    
                    // 如果有总体均值，添加到图表
                                    if (result.populationMean !== undefined) {
                                        // 找到总体均值对应的索引
                                        let meanIndex = Math.floor(((result.populationMean - min) / (max - min)) * pointCount);
                                        meanIndex = Math.max(0, Math.min(pointCount - 1, meanIndex));
                                        
                                        const populationMeanData = new Array(pointCount).fill(null);
                                        populationMeanData[meanIndex] = normalData[meanIndex];
                                        
                                        datasets.push({
                                            label: i18n.t('chart.population.mean'),
                                            data: populationMeanData,
                                            backgroundColor: 'rgba(76, 175, 80, 1)',
                                            borderColor: 'rgba(76, 175, 80, 1)',
                                            borderWidth: 2,
                                            pointRadius: 6,
                                            pointHoverRadius: 8,
                                            showLine: false
                                        });
                                    }
                    
                    // 准备注释配置
                    const annotations = {
                        lowerBoundLine: {
                            type: 'line',
                            xMin: result.lowerBound,
                            xMax: result.lowerBound,
                            borderColor: 'rgba(244, 67, 54, 0.8)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            label: {
                                content: `${i18n.t('chart.main.lower.bound')}: ${result.lowerBound.toFixed(4)}`,
                                enabled: true,
                                position: 'top'
                            }
                        },
                        upperBoundLine: {
                            type: 'line',
                            xMin: result.upperBound,
                            xMax: result.upperBound,
                            borderColor: 'rgba(244, 67, 54, 0.8)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            label: {
                                content: `${i18n.t('chart.main.upper.bound')}: ${result.upperBound.toFixed(4)}`,
                                enabled: true,
                                position: 'top'
                            }
                        }
                    };
                    
                    // 如果有T检验参考结果，添加T检验的边界线
                    if (result.tLowerBound !== undefined) {
                        annotations.tLowerBoundLine = {
                            type: 'line',
                            xMin: result.tLowerBound,
                            xMax: result.tLowerBound,
                            borderColor: 'rgba(255, 99, 132, 0.6)',
                            borderWidth: 2,
                            borderDash: [3, 3],
                            label: {
                                    content: `${i18n.t('chart.t.test.lower.bound')}: ${result.tLowerBound.toFixed(4)}`,
                                    enabled: true,
                                    position: 'bottom'
                                }
                        };
                        
                        annotations.tUpperBoundLine = {
                            type: 'line',
                            xMin: result.tUpperBound,
                            xMax: result.tUpperBound,
                            borderColor: 'rgba(255, 99, 132, 0.6)',
                            borderWidth: 2,
                            borderDash: [3, 3],
                            label: {
                                    content: `${i18n.t('chart.t.test.upper.bound')}: ${result.tUpperBound.toFixed(4)}`,
                                    enabled: true,
                                    position: 'bottom'
                                }
                        };
                    }
                    
                    // 创建图表
                    this.currentChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: xLabels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                        x: {
                                            title: {
                                                display: true,
                                                text: i18n.t('chart.value')
                                            }
                                        },
                                        y: {
                                            beginAtZero: true,
                                            title: {
                                                display: true,
                                                text: i18n.t('chart.probability.density')
                                            }
                                        }
                                    },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${result.method} - ${result.confidenceLevel * 100}% ${i18n.t('stats.confidence.interval')} Analysis`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label.includes(i18n.t('stats.confidence.interval'))) {
                                                if (label.includes(i18n.t('stats.t.test.reference'))) {
                                                    return `${label}: [${result.tLowerBound.toFixed(4)}, ${result.tUpperBound.toFixed(4)}]`;
                                                } else {
                                                    return `${label}: [${result.lowerBound.toFixed(4)}, ${result.upperBound.toFixed(4)}]`;
                                                }
                                            } else if (label === i18n.t('chart.sample.mean')) {
                                                return `${label}: ${result.sampleMean.toFixed(4)}`;
                                            } else if (label === i18n.t('chart.population.mean') && result.populationMean !== undefined) {
                                                return `${label}: ${result.populationMean.toFixed(4)}`;
                                            }
                                            return label;
                                        }
                                    }
                                },
                                annotation: {
                                    annotations: annotations
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error drawing confidence interval chart:', error);
                    alert(i18n.t('alert.failed.to.create.chart') + ': ' + error.message);
                }
            },
            
            // 清除置信区间结果
            clearConfidenceResults() {
                try {
                    // 销毁图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 隐藏结果容器
                    document.getElementById('confidence-results').classList.add('hidden');
                    document.getElementById('confidence-interpretation').classList.add('hidden');
                    document.getElementById('sample-size-result').classList.add('hidden');
                    document.getElementById('sample-size-calculator').classList.add('hidden');
                } catch (error) {
                    console.error('Error clearing confidence interval results:', error);
                }
            },
            
            // 生成置信区间样本数据（仅用于置信区间分析）
            generateConfidenceSampleData(distributionType, sampleSize, mean, std) {
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    if (distributionType === 'normal') {
                        // 使用Box-Muller变换生成正态分布随机数
                        let u1, u2;
                        do {
                            u1 = Math.random();
                            u2 = Math.random();
                        } while (u1 <= Number.EPSILON);
                        
                        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        data.push(mean + z0 * std);
                    } else if (distributionType === 'uniform') {
                        // 生成均匀分布随机数
                        // 均匀分布的标准差 = (max - min) / Math.sqrt(12)
                        // 因此 max = mean + std * Math.sqrt(12) / 2
                        //     min = mean - std * Math.sqrt(12) / 2
                        const range = std * Math.sqrt(12);
                        const min = mean - range / 2;
                        const max = mean + range / 2;
                        data.push(min + Math.random() * (max - min));
                    }
                }
                
                return data;
            },
            
            // 数据分析
            analyzeData() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    
                    if (inputMethod === 'distribution') {
                        // 使用分布生成的数据
                        if (!this.generatedData) {
                            alert(i18n.t('error.no.data.generated'));
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    } else if (inputMethod === 'file') {
                        // 使用上传的文件数据
                        // 文件上传处理逻辑将在handleFileUpload中设置this.generatedData
                        if (!this.generatedData) {
                            alert(i18n.t('alert.please.select.file'));
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    } else if (inputMethod === 'ai') {
                        // 使用AI生成的数据
                        if (!this.generatedData) {
                            alert(i18n.t('error.no.data.generated'));
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    }
                } catch (error) {
                    console.error('Error analyzing data:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            // 更新图表
            updateChart() {
                try {
                    const chartType = document.getElementById('chart-type').value;
                    const ctx = document.getElementById('analysis-chart').getContext('2d');
                    const chartContainer = document.getElementById('analysis-chart-container');
                    
                    // 显示图表容器
                    if (chartContainer) {
                        chartContainer.classList.remove('hidden');
                    }
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    const data = this.generatedData;
                    let chartConfig;
                    
                    switch (chartType) {
                        case 'histogram':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'bar':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'scatter':
                            chartConfig = this.createScatterConfig(data);
                            break;
                        case 'line':
                            chartConfig = this.createLineConfig(data);
                            break;
                        default:
                            chartConfig = this.createHistogramConfig(data);
                    }
                    
                    // 创建图表
                    this.currentChart = new Chart(ctx, chartConfig);
                } catch (error) {
                    console.error('更新图表时出错:', error);
                    alert('更新图表失败，请重试');
                }
            },
            
            // 创建直方图配置
            createHistogramConfig(data) {
                // 计算直方图数据
                const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binWidth = (max - min) / binCount;
                
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                for (let i = 0; i < binCount; i++) {
                    binLabels.push((min + i * binWidth).toFixed(2));
                }
                
                data.forEach(value => {
                    if (value >= min && value <= max) {
                        const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                        bins[binIndex]++;
                    }
                });
                
                // 归一化频率
                const frequencies = bins.map(count => count / data.length);
                
                return {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: i18n.t('chart.frequency'),
                            data: frequencies,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: i18n.t('chart.value')
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxRotation: 0,
                                    callback: function(value, index, values) {
                                        // 只显示部分标签以避免拥挤
                                        return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                    }
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: '频率'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(3);
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${i18n.t('chart.histogram.analysis')} (${i18n.t('sample.size')}: ${data.length})`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 创建散点图配置
            createScatterConfig(data) {
                // 准备散点图数据
                const scatterData = data.slice(0, 1000).map((value, index) => ({
                    x: index,
                    y: value
                }));
                
                return {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: i18n.t('chart.data.points'),
                            data: scatterData,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            pointRadius: 3,
                            pointHoverRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: i18n.t('chart.index')
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '值'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${i18n.t('chart.scatter.analysis')} (${i18n.t('showing.first.n.points', { n: 1000 })})`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 创建折线图配置
            createLineConfig(data) {
                // 准备折线图数据（取前1000个点以避免图表过于密集）
                const displayData = data.slice(0, 1000);
                const indices = Array.from({ length: displayData.length }, (_, i) => i);
                
                return {
                    type: 'line',
                    data: {
                        labels: indices,
                        datasets: [{
                            label: i18n.t('chart.data.trend'),
                            data: displayData,
                            backgroundColor: 'rgba(74, 111, 165, 0.1)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '索引'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '值'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${i18n.t('chart.line.analysis')} (${i18n.t('showing.first.n.points', { n: 1000 })})`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 处理文件上传
            handleFileUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            const data = this.parseCSVData(content);
                            
                            if (data.length === 0) {
                                alert('未能从文件中解析出数据');
                                return;
                            }
                            
                            this.generatedData = data;
                            alert(`成功导入 ${data.length} 个数据点`);
                        } catch (error) {
                            console.error('解析文件时出错:', error);
                            alert('解析文件失败，请检查文件格式');
                        }
                    };
                    
                    reader.onerror = () => {
                        alert('读取文件失败');
                    };
                    
                    reader.readAsText(file);
                } catch (error) {
                    console.error('处理文件上传时出错:', error);
                    alert('上传文件失败，请重试');
                }
            },
            
            // 解析CSV数据
            parseCSVData(content) {
                // 尝试不同的CSV格式解析
                const lines = content.split(/[\r\n]+/).filter(line => line.trim() !== '');
                const data = [];
                
                // 尝试每行一个数据
                if (lines.length > 0 && lines[0].indexOf(',') === -1) {
                    for (const line of lines) {
                        const value = parseFloat(line.trim());
                        if (!isNaN(value)) {
                            data.push(value);
                        }
                    }
                } else {
                    // 尝试逗号分隔的数据
                    for (const line of lines) {
                        const values = line.split(',').map(val => parseFloat(val.trim()));
                        for (const value of values) {
                            if (!isNaN(value)) {
                                data.push(value);
                            }
                        }
                    }
                }
                
                return data;
            },
            
            // 切换数据输入方式
            switchDataInputMethod() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    const fileInputContainer = document.getElementById('file-data-input');
                    const aiInputContainer = document.getElementById('ai-data-input');
                    
                    // 处理文件输入容器
                    if (fileInputContainer) {
                        if (inputMethod === 'file') {
                            fileInputContainer.classList.remove('hidden');
                        } else {
                            fileInputContainer.classList.add('hidden');
                            // 清除文件输入
                            const fileInput = document.getElementById('file-upload');
                            if (fileInput) {
                                fileInput.value = '';
                            }
                        }
                    }
                    
                    // 处理AI输入容器
                    if (aiInputContainer) {
                        if (inputMethod === 'ai') {
                            aiInputContainer.classList.remove('hidden');
                        } else {
                            aiInputContainer.classList.add('hidden');
                        }
                    }
                } catch (error) {
                    console.error('切换数据输入方式时出错:', error);
                }
            },
            
            // AI生成数据
            generateAIData() {
                console.log('开始AI生成数据...');
                try {
                    const description = document.getElementById('ai-data-description').value;
                    const count = parseInt(document.getElementById('ai-data-count').value);
                    const seed = document.getElementById('ai-data-seed').value ? parseInt(document.getElementById('ai-data-seed').value) : null;
                    
                    // 验证输入
                    if (!description.trim()) {
                        alert('请输入数据描述');
                        return;
                    }
                    
                    if (isNaN(count) || count < 100 || count > 10000) {
                        alert(i18n.t('alert.invalid.sample.size'));
                        return;
                    }
                    
                    // 显示进度条
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = 'AI正在生成数据...';
                    }
                    
                    // 模拟生成过程中的进度更新
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `AI正在生成数据... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // 定义清理函数
                    const cleanup = () => {
                        clearInterval(interval);
                        if (progressContainer) {
                            progressContainer.classList.add('hidden');
                        }
                    };
                    
                    // 尝试使用真实的AI API
                    if (this.ai && this.ai.isConfigured) {
                        console.log('使用真实AI API生成数据');
                        
                        // 构建提示词
                        const prompt = `根据以下描述生成${count}个数值数据点：\n${description}\n\n请生成一个包含${count}个数值的数组，每个数值单独一行。不要包含任何额外的文字、解释或格式，只需要纯数值数据。`;
                        
                        // 调用AI API
                        this.generateWithRealAI(prompt, count, progressFill, progressText, cleanup);
                    } else {
                        console.log('使用模拟AI生成数据（未配置真实AI API）');
                        
                        // 如果没有配置真实AI，显示提示
                        if (!this.ai) {
                            console.warn('AI集成未初始化');
                        } else {
                            console.warn('未配置AI API密钥，点击"AI设置"按钮进行配置');
                        }
                        
                        // 继续使用模拟AI生成数据
                        setTimeout(() => {
                            try {
                                // 根据描述和随机种子生成数据
                                let data = this.simulateAIDataGeneration(description, count, seed);
                                
                                // 确保数据生成成功
                                if (!data || data.length === 0) {
                                    throw new Error('AI数据生成失败，返回空数据');
                                }
                                
                                console.log('模拟AI数据生成成功，长度:', data.length);
                                this.generatedData = data;
                                
                                // 更新进度条为100%
                                if (progressFill && progressText) {
                                    progressFill.style.width = '100%';
                                    progressText.textContent = 'AI数据生成完成！';
                                }
                                
                                alert(`模拟AI数据生成成功！已生成 ${data.length} 个数据点\n\n提示：配置真实AI API可获得更准确的数据生成结果。点击"AI设置"按钮进行配置。`);
                                
                                // 隐藏进度条
                                setTimeout(() => {
                                    cleanup();
                                }, 500);
                            } catch (error) {
                                console.error('模拟AI生成数据时出错:', error);
                                alert(i18n.t('alert.failed.to.generate.data') + ': ' + error.message);
                                cleanup();
                            }
                        }, 1500);
                    }
                } catch (error) {
                    console.error('调用AI生成数据函数时出错:', error);
                    alert(i18n.t('alert.failed.to.generate.data') + ': ' + error.message);
                }
            },
            
            // 使用真实AI API生成数据
            async generateWithRealAI(prompt, count, progressFill, progressText, cleanup) {
                try {
                    // 更新进度文本
                    if (progressText) {
                        progressText.textContent = '正在调用AI API...';
                    }
                    
                    // 调用DashScope API
                    const response = await fetch(`${this.ai.baseUrl}/services/aigc/text-generation/generation`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.ai.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: this.ai.model,
                            input: {
                                messages: [
                                    { role: 'user', content: prompt }
                                ]
                            }
                        })
                    });
                    
                    // 更新进度
                    if (progressFill && progressText) {
                        progressFill.style.width = '70%';
                        progressText.textContent = '正在解析AI响应...';
                    }
                    
                    if (response.ok) {
                        const result = await response.json();
                        const aiText = result.output.text;
                        
                        // 解析AI生成的数值数据
                        const lines = aiText.trim().split('\n');
                        const data = [];
                        
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (trimmedLine) {
                                const num = parseFloat(trimmedLine);
                                if (!isNaN(num)) {
                                    data.push(num);
                                }
                            }
                        }
                        
                        // 如果AI生成的数据不足，使用模拟数据补充
                        if (data.length < count * 0.5) {
                            console.warn(`AI只生成了${data.length}个数据点，使用模拟数据补充`);
                            const simulatedData = this.simulateAIDataGeneration(prompt, count - data.length, null);
                            data.push(...simulatedData);
                        } else if (data.length > count) {
                            // 如果生成的数据过多，截取前count个
                            data.length = count;
                        }
                        
                        console.log('真实AI数据生成成功，长度:', data.length);
                        this.generatedData = data;
                        
                        // 更新进度条为100%
                        if (progressFill && progressText) {
                            progressFill.style.width = '100%';
                            progressText.textContent = 'AI数据生成完成！';
                        }
                        
                        alert(`真实AI数据生成成功！已生成 ${data.length} 个数据点`);
                        
                        // 隐藏进度条
                        setTimeout(() => {
                            cleanup();
                        }, 500);
                    } else {
                        const errorText = await response.text();
                        throw new Error(`API调用失败: ${response.status} - ${errorText}`);
                    }
                } catch (error) {
                    console.error('真实AI生成数据时出错:', error);
                    alert(i18n.t('alert.failed.to.generate.data') + `: ${error.message}\n\n将回退到模拟AI生成...`);
                    
                    // 回退到模拟AI
                    try {
                        const data = this.simulateAIDataGeneration(prompt, count, null);
                        if (data && data.length > 0) {
                            this.generatedData = data;
                            console.log('回退到模拟AI成功，长度:', data.length);
                        }
                    } catch (e) {
                        console.error('回退到模拟AI也失败:', e);
                    } finally {
                        cleanup();
                    }
                }
            },
            
            // 模拟AI数据生成（基于描述和种子）
            simulateAIDataGeneration(description, count, seed) {
                console.log('模拟AI数据生成，描述:', description, '数量:', count, '种子:', seed);
                
                // 设置随机种子
                if (seed !== null) {
                    Math.seedrandom = function(seed) {
                        var s = seed + '';
                        Math.sin(s.charCodeAt(0))
                    };
                    Math.seedrandom(seed);
                }
                
                // 根据描述分析数据模式
                let data = [];
                const hasTrend = description.toLowerCase().includes('趋势') || description.toLowerCase().includes('trend');
                const hasVolatility = description.toLowerCase().includes('波动') || description.toLowerCase().includes('volatility');
                const hasSeasonality = description.toLowerCase().includes('季节性') || description.toLowerCase().includes('seasonal');
                const isStockLike = description.toLowerCase().includes('股票') || description.toLowerCase().includes('stock') || description.toLowerCase().includes('price');
                const isNormal = description.toLowerCase().includes('正态') || description.toLowerCase().includes('normal');
                const isUniform = description.toLowerCase().includes('均匀') || description.toLowerCase().includes('uniform');
                
                // 根据不同特征生成数据
                if (isNormal) {
                    // 正态分布数据
                    const mean = 50 + Math.random() * 50;
                    const stdDev = 10 + Math.random() * 20;
                    for (let i = 0; i < count; i++) {
                        data.push(this.normalRandom(mean, stdDev));
                    }
                } else if (isUniform) {
                    // 均匀分布数据
                    const min = Math.random() * 100;
                    const max = min + 100 + Math.random() * 100;
                    for (let i = 0; i < count; i++) {
                        data.push(min + Math.random() * (max - min));
                    }
                } else if (isStockLike || hasTrend) {
                    // 股票价格类数据（带趋势）
                    let price = 100 + Math.random() * 100;
                    const trend = (Math.random() - 0.45) * 2; // 轻微正趋势
                    const volatility = hasVolatility ? (0.01 + Math.random() * 0.02) : 0.01;
                    
                    for (let i = 0; i < count; i++) {
                        // 添加季节性影响
                        const seasonal = hasSeasonality ? Math.sin(i / 20) * 5 : 0;
                        // 添加随机波动
                        const randomChange = (Math.random() - 0.5) * 2 * volatility * price;
                        // 更新价格
                        price = price * (1 + trend / 100) + randomChange + seasonal;
                        // 确保价格为正
                        price = Math.max(price, 0.1);
                        data.push(price);
                    }
                } else {
                    // 默认混合分布数据
                    for (let i = 0; i < count; i++) {
                        // 根据描述中可能包含的关键词调整生成逻辑
                        if (description.toLowerCase().includes('增长') || description.toLowerCase().includes('increase')) {
                            // 增长趋势数据
                            data.push(100 + i * (0.5 + Math.random() * 0.5) + (Math.random() - 0.5) * 20);
                        } else if (description.toLowerCase().includes('周期') || description.toLowerCase().includes('cycle')) {
                            // 周期性数据
                            data.push(100 + Math.sin(i / 10) * 50 + (Math.random() - 0.5) * 20);
                        } else {
                            // 默认正态分布带一些变化
                            data.push(100 + (Math.random() - 0.5) * 100);
                        }
                    }
                }
                
                return data;
            },
            
            // 正态分布随机数生成
            normalRandom(mean, stdDev) {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                return mean + z * stdDev;
            },
            
            // 重置分析
            resetAnalysis() {
                try {
                    // 销毁图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 隐藏图表容器
                    const chartContainer = document.getElementById('analysis-chart-container');
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    // 重置文件输入
                    const fileInput = document.getElementById('file-upload');
                    if (fileInput) {
                        fileInput.value = '';
                    }
                    
                    // 重置AI数据输入
                    const aiDescription = document.getElementById('ai-data-description');
                    const aiDataCount = document.getElementById('ai-data-count');
                    const aiDataSeed = document.getElementById('ai-data-seed');
                    
                    if (aiDescription) {
                        aiDescription.value = '';
                    }
                    
                    if (aiDataCount) {
                        aiDataCount.value = '1000';
                    }
                    
                    if (aiDataSeed) {
                        aiDataSeed.value = '';
                    }
                    
                    // 切换回分布输入方式
                    const distributionRadio = document.querySelector('input[name="data-input-method"][value="distribution"]');
                    if (distributionRadio) {
                        distributionRadio.checked = true;
                        this.switchDataInputMethod();
                    }
                } catch (error) {
                    console.error('重置分析时出错:', error);
                }
            },
            
            // 获取分布名称
            getDistributionName(type) {
                const names = {
                    'normal': '正态',
                    'binomial': '二项',
                    'poisson': '泊松',
                    'uniform': '均匀',
                    'exponential': '指数'
                };
                
                return names[type] || type;
            },
            
            // 假设检验相关方法
            initHypothesisTesting() {
                // 确保Math.erf函数可用，这对正态分布计算至关重要
                this.ensureMathErf();
                
                // 检验类型变化事件
                const testTypeElement = document.getElementById('test-type');
                if (testTypeElement) {
                    testTypeElement.addEventListener('change', () => {
                        try {
                            this.toggleTestParameters();
                        } catch (error) {
                            console.error('切换检验参数时出错:', error);
                        }
                    });
                }
                
                // 样本方法变化事件
                const sampleMethodElement = document.getElementById('sample-method');
                const manualSampleElement = document.getElementById('manual-sample-input');
                if (sampleMethodElement && manualSampleElement) {
                    sampleMethodElement.addEventListener('change', () => {
                        try {
                            const method = sampleMethodElement.value;
                            manualSampleElement.classList.toggle('hidden', method !== 'manual-entry');
                        } catch (error) {
                            console.error('切换样本方法时出错:', error);
                        }
                    });
                }
                
                // 计算检验按钮事件
                const calculateButton = document.getElementById('calculate-test');
                if (calculateButton) {
                    calculateButton.addEventListener('click', () => {
                        try {
                            this.calculateHypothesisTest();
                        } catch (error) {
                            console.error('计算假设检验时出错:', error);
                            alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                        }
                    });
                }
                
                // 清除结果按钮事件
                const clearButton = document.getElementById('clear-test-results');
                if (clearButton) {
                    clearButton.addEventListener('click', () => {
                        try {
                            this.clearTestResults();
                        } catch (error) {
                            console.error('清除检验结果时出错:', error);
                        }
                    });
                }
                
                // 初始调用一次参数切换函数
                try {
                    this.toggleTestParameters();
                } catch (error) {
                    console.error('初始化检验参数时出错:', error);
                }
            },
            
            toggleTestParameters() {
                const testType = document.getElementById('test-type').value;
                
                // 显示/隐藏不同检验类型的参数区域
                document.getElementById('one-sample-params').classList.toggle('hidden', 
                    testType !== 'z-test' && testType !== 't-test');
                document.getElementById('two-sample-params').classList.toggle('hidden', 
                    testType !== 'two-sample-t');
                document.getElementById('anova-params').classList.toggle('hidden', 
                    testType !== 'anova');
                
                // 对于方差分析，默认使用手动输入
                if (testType === 'anova') {
                    document.getElementById('sample-method').value = 'manual-entry';
                    document.getElementById('manual-sample-input').classList.remove('hidden');
                }
            },
            
            calculateHypothesisTest() {
                try {
                    const testType = document.getElementById('test-type').value;
                    const significanceLevel = parseFloat(document.getElementById('significance-level').value);
                    
                    // 验证显著性水平
                    if (isNaN(significanceLevel) || significanceLevel <= 0 || significanceLevel >= 1) {
                        throw new Error('Significance level must be between 0 and 1');
                    }
                    
                    let results = null;
                    
                    switch(testType) {
                        case 'z-test':
                            const hypothesizedMeanZ = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanZ)) {
                                throw new Error('请输入有效的假设均值');
                            }
                            results = this.calculateZTest(significanceLevel, hypothesizedMeanZ);
                            break;
                        case 't-test':
                            const hypothesizedMeanT = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanT)) {
                                throw new Error('请输入有效的假设均值');
                            }
                            results = this.calculateTTest(significanceLevel, hypothesizedMeanT);
                            break;
                        case 'two-sample-t':
                            const testDirectionT = document.getElementById('test-direction').value;
                            results = this.calculateTwoSampleTTest(significanceLevel, testDirectionT);
                            break;
                        case 'anova':
                            results = this.calculateANOVA(significanceLevel);
                            break;
                        default:
                            throw new Error('未知的检验类型');
                    }
                    
                    if (results) {
                        this.displayTestResults(results);
                    }
                } catch (error) {
                    console.error('假设检验计算错误:', error);
                    alert(i18n.t('alert.calculation.failed') + ': ' + error.message);
                }
            },
            
            calculateZTest(significanceLevel, hypothesizedMean) {
                // 从DOM获取检验方向
                const testDirection = document.getElementById('test-direction').value;
                const populationStd = document.getElementById('population-std').value;
                
                // 验证数据和参数
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error(i18n.t('error.no.data.generated'));
                }
                
                // 验证总体标准差
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('请输入有效的总体标准差');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 计算p值
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // 计算临界值
                let criticalValue;
                const alpha = significanceLevel;
                
                if (testDirection === 'two-tailed') {
                    criticalValue = this.getZScore(1 - alpha/2);
                } else if (testDirection === 'left-tailed') {
                    criticalValue = -this.getZScore(1 - alpha);
                } else {
                    criticalValue = this.getZScore(1 - alpha);
                }
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Z检验',
                    sampleMean,
                    hypothesizedMean,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        i18n.t('hypothesis.reject.null', { significanceLevel: significanceLevel }) : 
                        i18n.t('hypothesis.fail.to.reject.null', { significanceLevel: significanceLevel })
                };
            },
            
            calculateTTest(significanceLevel, hypothesizedMean) {
                // 从DOM获取检验方向
                const testDirection = document.getElementById('test-direction').value;
                
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('请先在概率分布模拟或数据分析中生成或导入数据');
                }
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleStd = this.calculateStandardDeviation(this.generatedData);
                const sampleSize = this.generatedData.length;
                const degreesOfFreedom = sampleSize - 1;
                const standardError = sampleStd / Math.sqrt(sampleSize);
                const tScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 这里简化处理，使用近似的t分布p值计算
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                // 计算临界值
                let criticalValue = this.approximateTCriticalValue(degreesOfFreedom, significanceLevel, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'T检验',
                    sampleMean,
                    hypothesizedMean,
                    sampleStd,
                    sampleSize,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        i18n.t('hypothesis.reject.null', { significanceLevel: significanceLevel }) : 
                        i18n.t('hypothesis.fail.to.reject.null', { significanceLevel: significanceLevel })
                };
            },
            
            calculateTwoSampleTTest(significanceLevel, testDirection) {
                let sample1, sample2;
                
                const sampleMethod = document.getElementById('sample-method').value;
                
                if (sampleMethod === 'use-generated') {
                    if (!this.generatedData || this.generatedData.length < 2) {
                        throw new Error('使用已生成数据需要至少2个数据点');
                    }
                    // 简单地将数据分成两半
                    const midPoint = Math.floor(this.generatedData.length / 2);
                    sample1 = this.generatedData.slice(0, midPoint);
                    sample2 = this.generatedData.slice(midPoint);
                } else {
                    // 手动输入
                    const sample1Text = document.getElementById('sample1-data').value.trim();
                    const sample2Text = document.getElementById('sample2-data').value.trim();
                    
                    if (!sample1Text || !sample2Text) {
                        throw new Error('请输入两个样本的数据');
                    }
                    
                    sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    
                    if (sample1.length === 0 || sample2.length === 0) {
                        throw new Error(i18n.t('error.invalid.sample.format'));
                    }
                }
                
                // 计算样本统计量
                const mean1 = this.calculateMean(sample1);
                const mean2 = this.calculateMean(sample2);
                const std1 = this.calculateStandardDeviation(sample1);
                const std2 = this.calculateStandardDeviation(sample2);
                const n1 = sample1.length;
                const n2 = sample2.length;
                
                // 计算合并标准差
                const pooledVariance = ((n1 - 1) * std1 * std1 + (n2 - 1) * std2 * std2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVariance * (1/n1 + 1/n2));
                const tScore = (mean1 - mean2) / standardError;
                const degreesOfFreedom = n1 + n2 - 2;
                
                // 近似p值
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: '双样本T检验',
                    mean1,
                    mean2,
                    std1,
                    std2,
                    n1,
                    n2,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        i18n.t('hypothesis.reject.null.two.sample', { significanceLevel: significanceLevel }) : 
                        i18n.t('hypothesis.fail.to.reject.null.two.sample', { significanceLevel: significanceLevel })
                };
            },
            
            calculateANOVA(significanceLevel) {
                const sample1Text = document.getElementById('sample1-data').value.trim();
                const sample2Text = document.getElementById('sample2-data').value.trim();
                
                if (!sample1Text || !sample2Text) {
                    throw new Error(i18n.t('error.anova.needs.two.samples'));
                }
                
                const sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                const sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                
                if (sample1.length === 0 || sample2.length === 0) {
                    throw new Error('样本数据格式错误，请使用逗号分隔的数字');
                }
                
                const groups = [sample1, sample2];
                const k = groups.length; // 组数
                const n = groups.reduce((sum, group) => sum + group.length, 0); // 总样本数
                
                // 计算各组均值和总均值
                const groupMeans = groups.map(group => this.calculateMean(group));
                const grandMean = this.calculateMean(groups.flat());
                
                // 计算组间平方和
                let ssb = 0;
                groups.forEach((group, index) => {
                    ssb += group.length * Math.pow(groupMeans[index] - grandMean, 2);
                });
                
                // 计算组内平方和
                let ssw = 0;
                groups.forEach((group, index) => {
                    group.forEach(value => {
                        ssw += Math.pow(value - groupMeans[index], 2);
                    });
                });
                
                // 计算均方
                const msb = ssb / (k - 1); // 组间均方
                const msw = ssw / (n - k); // 组内均方
                
                // 计算F统计量
                const fStatistic = msb / msw;
                
                // 简化的p值计算
                const pValue = this.approximateFPValue(fStatistic, k - 1, n - k);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: '单因素方差分析',
                    groups: k,
                    totalSamples: n,
                    groupMeans,
                    grandMean,
                    fStatistic,
                    degreesOfFreedom: `${k-1}, ${n-k}`,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    resultMessage: rejectNull ? 
                        i18n.t('hypothesis.reject.null.anova', { significanceLevel: significanceLevel }) : 
                        i18n.t('hypothesis.fail.to.reject.null.anova', { significanceLevel: significanceLevel })
                };
            },
            
            displayTestResults(results) {
                const summaryContainer = document.getElementById('test-summary');
                summaryContainer.innerHTML = '';
                
                // 创建结果卡片
                const createStatCard = (title, value, description = '') => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.innerHTML = `
                        <h4>${title}</h4>
                        <div class="stat-value">${value}</div>
                        ${description ? `<div class="stat-description">${description}</div>` : ''}
                    `;
                    summaryContainer.appendChild(card);
                };
                
                // 根据检验类型显示不同的结果
                if (results.testType === 'Z检验' || results.testType === 'T检验') {
                    createStatCard(i18n.t('stats.testType'), results.testType);
                    createStatCard(i18n.t('stats.sample.mean'), results.sampleMean ? results.sampleMean.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.hypothesized.mean'), results.hypothesizedMean);
                    createStatCard(i18n.t('stats.sample.size'), results.sampleSize);
                    
                    if (results.testType === 'Z检验') {
                        createStatCard(i18n.t('stats.zScore'), results.zScore ? results.zScore.toFixed(4) : 'N/A');
                    } else {
                        createStatCard(i18n.t('stats.tScore'), results.tScore ? results.tScore.toFixed(4) : 'N/A');
                        createStatCard(i18n.t('stats.degreesOfFreedom'), results.degreesOfFreedom);
                    }
                    
                    createStatCard(i18n.t('stats.pValue'), results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard(i18n.t('hypothesis.significanceLevel'), results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>${i18n.t('stats.testConclusion')}</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                    
                    // 绘制图表
                    this.plotTestChart(results);
                } else if (results.testType === '双样本T检验') {
                    createStatCard(i18n.t('stats.testType'), results.testType);
                    createStatCard(i18n.t('stats.sample1.mean'), results.mean1 ? results.mean1.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.sample2.mean'), results.mean2 ? results.mean2.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.sample1.std'), results.std1 ? results.std1.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.sample2.std'), results.std2 ? results.std2.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.sample1.size'), results.n1);
                    createStatCard(i18n.t('stats.sample2.size'), results.n2);
                    createStatCard(i18n.t('stats.tScore'), results.tScore ? results.tScore.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.degreesOfFreedom'), results.degreesOfFreedom);
                    createStatCard(i18n.t('stats.pValue'), results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard(i18n.t('hypothesis.significanceLevel'), results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>${i18n.t('stats.testConclusion')}</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                } else if (results.testType === '单因素方差分析') {
                    createStatCard(i18n.t('stats.testType'), results.testType);
                    createStatCard(i18n.t('stats.groups.count'), results.groups);
                    createStatCard(i18n.t('stats.totalSamples'), results.totalSamples);
                    createStatCard(i18n.t('stats.fStatistic'), results.fStatistic ? results.fStatistic.toFixed(4) : 'N/A');
                    createStatCard(i18n.t('stats.degreesOfFreedom'), results.degreesOfFreedom);
                    createStatCard(i18n.t('stats.pValue'), results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard(i18n.t('hypothesis.significanceLevel'), results.significanceLevel);
                    
                    // 显示各组均值
                    if (results.groupMeans && Array.isArray(results.groupMeans)) {
                        results.groupMeans.forEach((mean, index) => {
                            createStatCard(i18n.t('stats.groupMean', { group: index + 1 }), mean ? mean.toFixed(4) : 'N/A');
                        });
                    }
                    
                    createStatCard(i18n.t('stats.grandMean'), results.grandMean ? results.grandMean.toFixed(4) : 'N/A');
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>${i18n.t('stats.testConclusion')}</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                }
                
                // 显示结果区域
                document.getElementById('test-results').classList.remove('hidden');
                document.getElementById('test-chart-container').classList.remove('hidden');
            },
            
            plotTestChart(results) {
                try {
                    const ctx = document.getElementById('test-chart')?.getContext('2d');
                    if (!ctx) {
                        console.error('图表上下文未找到');
                        return;
                    }
                    
                    // 销毁旧图表
                    if (this.testChart) {
                        this.testChart.destroy();
                    }
                    
                    let chartData = null;
                    let chartOptions = null;
                    
                    if (results.testType === 'Z检验' || results.testType === 'T检验') {
                        // 为Z检验或T检验创建分布图
                        const xValues = [];
                        const distributionValues = [];
                        const testStat = results.testType === 'Z检验' ? results.zScore : results.tScore;
                        
                        // 验证必要的数据存在
                        if (testStat === undefined || testStat === null) {
                            console.error('检验统计量不存在');
                            return;
                        }
                        
                        // 生成分布曲线数据
                        const min = Math.min(-4, testStat - 1);
                        const max = Math.max(4, testStat + 1);
                        for (let x = min; x <= max; x += 0.1) {
                            xValues.push(x);
                            if (results.testType === 'Z检验') {
                                distributionValues.push(this.normalPDF(x));
                            } else if (results.degreesOfFreedom) {
                                distributionValues.push(this.tDistributionPDF(x, results.degreesOfFreedom));
                            } else {
                                distributionValues.push(0); // 避免自由度不存在导致的错误
                            }
                        }
                        
                        // 创建p值区域数据
                        const pValueArea = [];
                        const testDirection = results.testDirection || 'two-tailed';
                        
                        if (testDirection === 'two-tailed') {
                            // 双侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (Math.abs(xValues[i]) >= Math.abs(testStat)) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else if (testDirection === 'right-tailed') {
                            // 右侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] >= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else {
                            // 左侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] <= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        }
                        
                        // 定义图表数据
                        chartData = {
                            labels: xValues,
                            datasets: [
                                {
                                    label: results.testType === 'Z检验' ? '标准正态分布' : 'T分布',
                                    data: distributionValues,
                                    borderColor: 'blue',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'p值区域',
                                    data: pValueArea,
                                    borderColor: 'red',
                                    backgroundColor: 'rgba(255, 99, 132, 0.3)',
                                    borderWidth: 0,
                                    fill: true
                                }
                            ]
                        };
                        
                        // 定义图表选项
                        chartOptions = {
                            responsive: true,
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${results.testType} 分布与p值可视化`
                                },
                                legend: {
                                    position: 'top'
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: results.testType === 'Z检验' ? 'Z值' : 'T值'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: '概率密度'
                                    },
                                    min: 0
                                }
                            }
                        };
                    }
                    
                    // 创建新图表
                    if (chartData && chartOptions && typeof Chart !== 'undefined') {
                        try {
                            this.testChart = new Chart(ctx, {
                                type: 'line',
                                data: chartData,
                                options: chartOptions
                            });
                        } catch (chartError) {
                            console.error('图表创建失败:', chartError);
                        }
                    }
                } catch (error) {
                    console.error('图表处理错误:', error);
                }
            },
              
              clearTestResults() {
                document.getElementById('test-results').classList.add('hidden');
                document.getElementById('test-chart-container').classList.add('hidden');
                
                if (this.testChart) {
                    this.testChart.destroy();
                    this.testChart = null;
                }
            },
            
            // 缺失的Z检验计算方法
            calculateZTest(significanceLevel, hypothesizedMean, testDirection) {
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('请先在概率分布模拟或数据分析中生成或导入数据');
                }
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const populationStd = document.getElementById('population-std').value;
                
                // 验证总体标准差是否有效
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('请输入有效的总体标准差');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 计算p值
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // 计算临界值
                let criticalValue = this.getZScore(1 - significanceLevel/2);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Z检验',
                    sampleMean,
                    hypothesizedMean,
                    populationStd: populationStdFloat,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设`
                };
            },
            
            // 缺失的Z分数获取方法
            getZScore(probability) {
                // 使用反误差函数计算Z分数
                // 使用近似公式计算逆正态分布
                if (probability <= 0) return -Infinity;
                if (probability >= 1) return Infinity;
                
                // Box-Muller变换的逆过程近似
                const z = Math.sqrt(-2 * Math.log(1 - probability)) * Math.cos(2 * Math.PI * probability);
                return z;
            },
            
            // 改进的T检验p值计算
            approximateTPValue(tScore, degreesOfFreedom, testDirection) {
                // 更精确的T分布p值计算
                try {
                    if (degreesOfFreedom > 30) {
                        // 大样本情况下用正态分布近似
                        const cumulativeProbability = this.normalCDF(tScore);
                        
                        switch(testDirection) {
                            case 'two-tailed':
                                return 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                            case 'left-tailed':
                                return cumulativeProbability;
                            case 'right-tailed':
                                return 1 - cumulativeProbability;
                        }
                    }
                    
                    // 使用更精确的近似计算
                    const absT = Math.abs(tScore);
                    
                    // 基于自由度和t统计量的更精确近似
                    // 这里使用更平滑的近似公式
                    const scaledT = absT / Math.sqrt(degreesOfFreedom / (degreesOfFreedom - 2));
                    let pValue = 1.0 / (1 + Math.pow(scaledT, degreesOfFreedom/2) * 0.5);
                    
                    // 调整p值使其在合理范围内
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    if (testDirection === 'two-tailed') {
                        pValue *= 2;
                    }
                    
                    return pValue;
                } catch (error) {
                    console.error('计算p值时出错:', error);
                    // 出错时返回默认值
                    return 0.5;
                }
            },
            
            // 改进的T临界值计算
            approximateTCriticalValue(degreesOfFreedom, alpha, testDirection) {
                try {
                    // 更精确的临界值计算
                    if (degreesOfFreedom > 100) {
                        // 使用Z临界值
                        return this.getZScore(1 - alpha/2);
                    }
                    
                    // 基于自由度的更精确临界值计算
                    // 使用近似公式
                    const z = this.getZScore(1 - alpha/2);
                    const correction = (z*z*z + z) / (4 * degreesOfFreedom);
                    const criticalValue = z + correction;
                    
                    // 根据检验方向调整
                    if (testDirection === 'left-tailed') {
                        return -criticalValue;
                    } else if (testDirection === 'right-tailed') {
                        return criticalValue;
                    }
                    
                    return criticalValue; // 双侧检验返回正临界值
                } catch (error) {
                    console.error('计算临界值时出错:', error);
                    // 出错时返回默认值
                    return 1.96; // 默认Z临界值
                }
            },
            
            // 改进的F检验p值计算
            approximateFPValue(fStatistic, dfBetween, dfWithin) {
                try {
                    if (fStatistic <= 0) return 1.0;
                    
                    // 使用更精确的F分布p值近似
                    // 使用Satterthwaite近似
                    const logF = Math.log(fStatistic);
                    const logNumerator = dfBetween / 2 * logF;
                    const logDenominator = Math.log(1 + (dfBetween / dfWithin) * fStatistic) * (dfBetween + dfWithin) / 2;
                    
                    // 简化的近似公式
                    let pValue = 1.0 / (1 + Math.exp(logNumerator - logDenominator));
                    
                    // 调整p值使其在合理范围内
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    return pValue;
                } catch (error) {
                    console.error('计算F检验p值时出错:', error);
                    // 出错时返回默认值
                    return 0.5;
                }
            },
            
            // 确保Math.erf函数可用的polyfill
            ensureMathErf() {
                if (!Math.erf) {
                    // 添加误差函数的polyfill
                    Math.erf = function(x) {
                        // 简化的误差函数实现
                        const z = Math.abs(x);
                        const t = 1.0 / (1.0 + z / 2.5);
                        const a1 = 0.254829592;
                        const a2 = -0.284496736;
                        const a3 = 1.421413741;
                        const a4 = -1.453152027;
                        const a5 = 1.061405429;
                        const erf = 1 - t * Math.exp(-z * z + a1 * t + a2 * t * t + a3 * t * t * t + a4 * t * t * t * t + a5 * t * t * t * t * t);
                        return x >= 0 ? erf : -erf;
                    };
                }
            },
            
            // 辅助统计方法
            calculateMean(data) {
                // 输入验证
                if (!Array.isArray(data) || data.length === 0) {
                    console.error('calculateMean: 无效的数据数组');
                    return 0;
                }
                
                try {
                    // 过滤掉非数值和NaN值
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length === 0) {
                        console.error('calculateMean: 数组中没有有效数值');
                        return 0;
                    }
                    
                    return validData.reduce((sum, value) => sum + value, 0) / validData.length;
                } catch (error) {
                    console.error('calculateMean: 计算均值时出错', error);
                    return 0;
                }
            },
            
            calculateStandardDeviation(data) {
                try {
                    // 输入验证
                    if (!Array.isArray(data) || data.length <= 1) {
                        console.error('calculateStandardDeviation: 数据数组长度不足');
                        return 0;
                    }
                    
                    const mean = this.calculateMean(data);
                    
                    // 过滤掉非数值和NaN值
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length <= 1) {
                        console.error('calculateStandardDeviation: 有效数据点不足');
                        return 0;
                    }
                    
                    const squaredDifferences = validData.map(value => Math.pow(value - mean, 2));
                    const variance = squaredDifferences.reduce((sum, value) => sum + value, 0) / (validData.length - 1);
                    return Math.sqrt(variance);
                } catch (error) {
                    console.error('calculateStandardDeviation: 计算标准差时出错', error);
                    return 0;
                }
            },
            
            // 正态分布CDF (使用近似计算)
            normalCDF(x) {
                return 0.5 * (1 + Math.erf(x / Math.sqrt(2)));
            },
            
            // 正态分布PDF
            normalPDF(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            },
            
            // T分布PDF近似
            tDistributionPDF(x, df) {
                const gamma = this.approximateGamma((df + 1) / 2) / (Math.sqrt(df * Math.PI) * this.approximateGamma(df / 2));
                return gamma * Math.pow(1 + x * x / df, -(df + 1) / 2);
            },
            
            // 近似伽马函数
            approximateGamma(z) {
                // 简化的伽马函数近似
                const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
                
                if (z < 0.5) {
                    return Math.PI / (Math.sin(Math.PI * z) * this.approximateGamma(1 - z));
                }
                
                z -= 1;
                let x = p[0];
                for (let i = 1; i < p.length; i++) {
                    x += p[i] / (z + i);
                }
                
                const t = z + p.length - 0.5;
                return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
            }
        };
        
        // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，开始初始化应用');
            
            // 创建全局的置信区间模块对象
            window.confidenceIntervalModule = {
                lastResult: null,
                lastSampleSizeParams: null
            };
            
            StatApp.init();
            
            // 在StatApp初始化后，尝试将必要的方法暴露给全局对象
            if (window.StatApp && window.StatApp.app) {
                const app = window.StatApp.app;
                if (app.displayConfidenceResults && app.generateInterpretation) {
                    window.confidenceIntervalModule.displayConfidenceResults = app.displayConfidenceResults.bind(app);
                    window.confidenceIntervalModule.generateInterpretation = app.generateInterpretation.bind(app);
                    window.confidenceIntervalModule.recalculateSampleSize = app.recalculateSampleSize ? app.recalculateSampleSize.bind(app) : function() {};
                }
            }
        });
    </script>
</body>
</html>