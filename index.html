<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>统计分布模拟分析工具</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="dashscope_integration.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cb7;
            --accent-color: #f9a03f;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --background-color: #f5f7fa;
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: var(--shadow);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* 统计卡片网格布局 */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stats-container {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--card-background);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
        }
        
        .stats-container h3 {
            margin-top: 0;
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background-color: white;
            border-radius: 8px 8px 0 0;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background-color: rgba(74, 111, 165, 0.05);
        }
        
        .tab.active {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary-color);
        }
        
        .tab-content {
            background-color: white;
            border-radius: 0 0 8px 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            min-height: 500px;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        button:hover {
            background-color: var(--secondary-color);
        }
        
        button.secondary {
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        button.secondary:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .button-group {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background-color: var(--background-color);
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
        }
        
        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .hidden {
            display: none;
        }
        
        /* 假设检验结果高亮样式 */
        .highlight-reject {
            background-color: #ffebee;
            border-left-color: #f44336;
            border-left-width: 5px;
        }
        
        .highlight-accept {
            background-color: #e8f5e9;
            border-left-color: #4caf50;
            border-left-width: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 9999;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--success-color);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .help-text {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 5px;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .badge-warning {
            background-color: var(--warning-color);
            color: white;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>统计分布模拟分析工具</h1>
            <p class="subtitle">通过模拟不同概率分布，进行数据分析与可视化</p>
        </div>
    </header>
    
    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="distribution">概率分布模拟</button>
            <button class="tab" data-tab="confidence">置信区间分析</button>
            <button class="tab" data-tab="analysis">数据分析</button>
            <button class="tab" data-tab="hypothesis">假设检验</button>
        </div>
        
        <div id="hypothesis" class="tab-content hidden">
            <h2>假设检验</h2>
            
            <div class="card">
                <h3>检验设置</h3>
                
                <div class="form-group">
                    <label for="test-type">检验类型</label>
                    <select id="test-type">
                        <option value="z-test">单样本Z检验</option>
                        <option value="t-test">单样本T检验</option>
                        <option value="two-sample-t">双样本T检验</option>
                        <option value="anova">单因素方差分析</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="significance-level">显著性水平 (α)</label>
                        <select id="significance-level">
                            <option value="0.01">0.01</option>
                            <option value="0.05" selected>0.05</option>
                            <option value="0.10">0.10</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="test-direction">检验方向</label>
                        <select id="test-direction">
                            <option value="two-tailed" selected>双侧检验</option>
                            <option value="left-tailed">左侧检验</option>
                            <option value="right-tailed">右侧检验</option>
                        </select>
                    </div>
                </div>
                
                <div id="one-sample-params">
                    <h4>单样本检验参数</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="population-mean">假设总体均值 (μ₀)</label>
                            <input type="number" id="population-mean" value="0" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label for="population-std">总体标准差 (σ) <span class="help-text">(Z检验需要)</span></label>
                            <input type="number" id="population-std" value="1" step="0.1" min="0.01">
                        </div>
                    </div>
                </div>
                
                <div id="two-sample-params" class="hidden">
                    <h4>双样本检验参数</h4>
                    <div class="form-group">
                        <label for="sample-method">样本选择方式</label>
                        <select id="sample-method">
                            <option value="use-generated">使用已生成的数据</option>
                            <option value="manual-entry">手动输入</option>
                        </select>
                    </div>
                    <div id="manual-sample-input" class="hidden">
                        <div class="form-group">
                            <label for="sample1-data">样本1数据 (逗号分隔)</label>
                            <textarea id="sample1-data" rows="4" placeholder="例如: 1,2,3,4,5"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="sample2-data">样本2数据 (逗号分隔)</label>
                            <textarea id="sample2-data" rows="4" placeholder="例如: 2,3,4,5,6"></textarea>
                        </div>
                    </div>
                </div>
                
                <div id="anova-params" class="hidden">
                    <h4>方差分析参数</h4>
                    <div class="form-group">
                        <p>方差分析需要至少两组数据，请使用手动输入方式。</p>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calculate-test" class="btn btn-primary">计算假设检验</button>
                    <button id="clear-test-results" class="btn btn-secondary">清除结果</button>
                </div>
            </div>
            
            <div id="test-results" class="hidden">
                <h3>检验结果</h3>
                <div class="stats-container">
                    <div id="test-summary" class="stats-grid"></div>
                </div>
                
                <div id="test-chart-container" class="chart-container hidden">
                    <canvas id="test-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="distribution" class="tab-content">
            <h2>概率分布模拟</h2>
            
            <div class="form-group">
                <label for="distribution-type">分布类型</label>
                <select id="distribution-type">
                    <option value="normal">正态分布</option>
                    <option value="binomial">二项分布</option>
                    <option value="poisson">泊松分布</option>
                    <option value="uniform">均匀分布</option>
                    <option value="exponential">指数分布</option>
                </select>
            </div>
            
            <!-- 正态分布参数 -->
            <div id="normal-params" class="param-group">
                <div class="form-row">
                    <div class="form-group">
                        <label for="normal-mean">均值 (μ)</label>
                        <input type="number" id="normal-mean" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="normal-std">标准差 (σ)</label>
                        <input type="number" id="normal-std" value="1" step="0.1" min="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- 二项分布参数 -->
            <div id="binomial-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="binomial-n">试验次数 (n)</label>
                        <input type="number" id="binomial-n" value="10" step="1" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="binomial-p">成功概率 (p)</label>
                        <input type="number" id="binomial-p" value="0.5" step="0.01" min="0" max="1" required>
                    </div>
                </div>
            </div>
            
            <!-- 泊松分布参数 -->
            <div id="poisson-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="poisson-lambda">速率参数 (λ)</label>
                        <input type="number" id="poisson-lambda" value="5" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <!-- 均匀分布参数 -->
            <div id="uniform-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="uniform-min">最小值 (a)</label>
                        <input type="number" id="uniform-min" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="uniform-max">最大值 (b)</label>
                        <input type="number" id="uniform-max" value="1" step="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- 指数分布参数 -->
            <div id="exponential-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="exponential-lambda">速率参数 (λ)</label>
                        <input type="number" id="exponential-lambda" value="1" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="sample-size">样本大小</label>
                <input type="number" id="sample-size" value="1000" step="100" min="100" max="10000" required>
            </div>
            
            <div class="button-group">
                <button id="generate-data">生成数据</button>
                <button id="clear-data" class="secondary">清除数据</button>
            </div>
            
            <div id="distribution-chart-container" class="chart-container hidden">
                <canvas id="distribution-chart"></canvas>
            </div>
            
            <div id="distribution-stats" class="stats-grid hidden"></div>
        </div>
        
        <div id="confidence" class="tab-content hidden">
            <h2>置信区间分析</h2>
            
            <div class="form-group">
                <label for="confidence-level">置信水平</label>
                <select id="confidence-level">
                    <option value="0.90">90%</option>
                    <option value="0.95" selected>95%</option>
                    <option value="0.99">99%</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="population-mean">总体均值 (μ)</label>
                <input type="number" id="population-mean" value="0" step="0.1" required>
            </div>
            
            <div class="form-group">
                <label for="population-std">总体标准差 (σ)</label>
                <input type="number" id="population-std" value="1" step="0.1" min="0.1" required>
            </div>
            
            <div class="form-group">
                <label for="sample-size-confidence">样本大小</label>
                <input type="number" id="sample-size-confidence" value="30" step="1" min="1" required>
            </div>
            
            <div class="button-group">
                <button id="calculate-confidence">计算置信区间</button>
                <button id="generate-confidence-sample">生成样本</button>
            </div>
            
            <div id="confidence-chart-container" class="chart-container hidden">
                <canvas id="confidence-chart"></canvas>
            </div>
        </div>
        
        <div id="analysis" class="tab-content hidden">
            <h2>数据分析</h2>
            
            <div class="form-group">
                <label>数据输入方式</label>
                <div>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="distribution" checked> 使用分布生成数据</label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="file" style="margin-left: 20px;"> 上传CSV文件</label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="ai" style="margin-left: 20px;"> AI生成数据</label>
                </div>
            </div>
            
            <div id="file-data-input" class="form-group hidden">
                <label for="file-upload">上传CSV文件</label>
                <input type="file" id="file-upload" accept=".csv">
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">支持CSV格式，每行一个数据或逗号分隔的数据。</p>
            </div>
            
            <div id="ai-data-input" class="form-group hidden">
                <label for="ai-data-description">数据描述</label>
                <textarea id="ai-data-description" rows="3" placeholder="请描述您想要的数据特征，例如：生成1000个模拟股票价格数据，呈现一定的趋势和波动性"></textarea>
                <div class="form-row">
                    <div class="form-group" style="flex: 1; margin-right: 10px;">
                        <label for="ai-data-count">数据点数量</label>
                        <input type="number" id="ai-data-count" min="100" max="10000" value="1000">
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="ai-data-seed">随机种子（可选）</label>
                        <input type="number" id="ai-data-seed" min="0" max="999999">
                    </div>
                </div>
                <button id="generate-ai-data" class="btn btn-primary">生成AI数据</button>
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">基于您的描述，系统将生成符合特征的模拟数据。</p>
            </div>
            
            <div class="form-group">
                    <label for="chart-type">图表类型</label>
                    <select id="chart-type">
                        <option value="histogram">直方图</option>
                        <option value="bar">条形图</option>
                        <option value="scatter">散点图</option>
                        <option value="line">折线图</option>
                    </select>
                </div>
            
            <div class="button-group">
                <button id="analyze-data">分析数据</button>
                <button id="reset-analysis" class="secondary">重置分析</button>
            </div>
            
            <!-- 参数估计方法选择 -->
            <div id="parameter-estimation" class="form-group">
                <h3>参数估计</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="estimation-method">估计方法:</label>
                    <select id="estimation-method">
                        <option value="mom">矩估计法(MOM)</option>
                        <option value="mle">最大似然估计法(MLE)</option>
                    </select>
                    <button id="reestimate-btn" class="btn btn-secondary">重新估计参数</button>
                </div>
            </div>
            
            <!-- 参数估计结果 -->
            <div id="parameter-estimation-results" class="stats-container hidden">
                <h3>参数估计结果</h3>
                <div id="estimation-results-grid" class="stats-grid"></div>
            </div>
            
            <div id="analysis-chart-container" class="chart-container hidden">
                <canvas id="analysis-chart"></canvas>
            </div>
        </div>
    </div>
    
    <!-- 进度条 -->
    <div id="generation-progress" class="progress-container hidden">
        <div class="progress-fill"></div>
        <div class="progress-text">正在生成数据...</div>
    </div>
    
    <script>
        // 统计应用程序对象
        const StatApp = {
            // 应用程序状态
            currentChart: null,
            generatedData: null,
            ai: null,
            
            // 初始化应用程序
            init() {
                console.log('初始化应用程序...');
                try {
                    this.setupEventListeners();
                    this.setupTabs();
                    this.setupDistributionTypeChange();
                    this.setupChartTypeChangeListener();
                    // 初始化AI集成
                    this.initAIIntegration();
                    // 设置参数估计按钮点击事件
                    this.setupParameterEstimationButton();
                    // 初始化假设检验功能
                    this.initHypothesisTesting();
                    console.log('应用程序初始化完成');
                } catch (error) {
                    console.error('初始化应用时出错:', error);
                    alert('应用程序初始化失败: ' + error.message);
                }
            },
            
            // 设置参数估计按钮点击事件
            setupParameterEstimationButton() {
                const reestimateBtn = document.getElementById('reestimate-btn');
                if (reestimateBtn) {
                    reestimateBtn.addEventListener('click', () => {
                        this.estimateParameters();
                    });
                }
            },
            
            // 参数估计方法
            estimateParameters() {
                try {
                    if (!this.generatedData) {
                        alert('请先生成或上传数据');
                        return;
                    }
                    
                    const estimationMethod = document.getElementById('estimation-method').value;
                    const resultsGrid = document.getElementById('estimation-results-grid');
                    const resultsContainer = document.getElementById('parameter-estimation-results');
                    
                    if (resultsGrid) {
                        resultsGrid.innerHTML = '';
                    }
                    
                    // 计算基本统计量
                    const mean = this.generatedData.reduce((sum, val) => sum + val, 0) / this.generatedData.length;
                    const variance = this.generatedData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.generatedData.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // 根据选择的方法进行参数估计
                    let params;
                    let methodName;
                    
                    if (estimationMethod === 'mom') {
                        // 矩估计法
                        methodName = '矩估计法(MOM)';
                        // 正态分布的矩估计参数
                        params = {
                            '均值 (μ)': mean.toFixed(4),
                            '标准差 (σ)': stdDev.toFixed(4),
                            '方差 (σ²)': variance.toFixed(4)
                        };
                    } else if (estimationMethod === 'mle') {
                        // 最大似然估计法
                        methodName = '最大似然估计法(MLE)';
                        // 正态分布的MLE参数（对于正态分布，MLE与MOM结果相同）
                        params = {
                            '均值 (μ)': mean.toFixed(4),
                            '标准差 (σ)': stdDev.toFixed(4),
                            '方差 (σ²)': variance.toFixed(4)
                        };
                    }
                    
                    // 显示估计方法名称
                    const methodHeader = document.createElement('div');
                    methodHeader.className = 'estimation-method-header';
                    methodHeader.style.cssText = `
                        grid-column: 1 / -1;
                        font-weight: bold;
                        color: var(--primary-color);
                        margin-bottom: 10px;
                        text-align: center;
                        padding: 5px;
                        border-bottom: 2px solid var(--primary-color);
                    `;
                    methodHeader.textContent = `使用${methodName}估计的参数`;
                    
                    if (resultsGrid) {
                        resultsGrid.appendChild(methodHeader);
                    }
                    
                    // 创建参数估计结果卡片
                    Object.entries(params).forEach(([label, value]) => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        card.style.cssText = `
                            background-color: var(--card-background);
                            border: 1px solid var(--border-color);
                            border-radius: 6px;
                            padding: 12px;
                            box-shadow: var(--shadow);
                            text-align: center;
                        `;
                        
                        const labelElem = document.createElement('div');
                        labelElem.style.cssText = `
                            font-size: 14px;
                            color: var(--text-secondary);
                            margin-bottom: 5px;
                        `;
                        labelElem.textContent = label;
                        
                        const valueElem = document.createElement('div');
                        valueElem.style.cssText = `
                            font-size: 18px;
                            font-weight: bold;
                            color: var(--text-primary);
                        `;
                        valueElem.textContent = value;
                        
                        card.appendChild(labelElem);
                        card.appendChild(valueElem);
                        
                        if (resultsGrid) {
                            resultsGrid.appendChild(card);
                        }
                    });
                    
                    // 显示结果容器
                    if (resultsContainer) {
                        resultsContainer.classList.remove('hidden');
                    }
                    
                } catch (error) {
                    console.error('参数估计时出错:', error);
                    alert('参数估计失败: ' + error.message);
                }
            },
            
            // 初始化AI集成
            initAIIntegration() {
                console.log('初始化AI集成');
                try {
                    // 创建DashScope集成实例
                    this.ai = new DashScopeIntegration();
                    // 尝试加载保存的API密钥
                    this.ai.loadApiKey();
                    
                    // 添加AI设置按钮
                    this.addAISettingsButton();
                } catch (error) {
                    console.warn('AI集成初始化失败:', error);
                    // 继续使用模拟AI作为后备
                }
            },
            
            // 添加AI设置按钮
            addAISettingsButton() {
                const aiInputContainer = document.getElementById('ai-data-input');
                if (aiInputContainer) {
                    const settingsButton = document.createElement('button');
                    settingsButton.id = 'ai-settings-button';
                    settingsButton.className = 'btn btn-outline-secondary';
                    settingsButton.style = 'margin-left: 10px;';
                    settingsButton.textContent = '🤖 AI设置';
                    settingsButton.onclick = () => this.showAISetup();
                    
                    const generateButton = document.getElementById('generate-ai-data');
                    if (generateButton) {
                        generateButton.parentNode.insertBefore(settingsButton, generateButton.nextSibling);
                    }
                }
            },
            
            // 显示AI设置模态框
            showAISetup() {
                // 创建模态框
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background-color: white;
                        border-radius: 8px;
                        padding: 20px;
                        width: 90%;
                        max-width: 500px;
                        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0;">🤖 AI 数据生成设置</h3>
                            <button id="close-modal" style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                                color: #666;
                            ">×</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">DashScope API 密钥</label>
                            <input type="password" id="api-key-input" style="
                                width: 100%;
                                padding: 10px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                                font-size: 14px;
                            " placeholder="输入您的 DashScope API 密钥">
                            <p style="font-size: 12px; color: #666; margin-top: 5px;">
                                从 <a href="https://dashscope.aliyun.com" target="_blank">阿里云 DashScope</a> 获取API密钥
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <button id="test-connection" style="
                                background-color: #4a6fa5;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">测试连接</button>
                            <button id="save-api-key" style="
                                background-color: #4caf50;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">保存 & 使用 AI</button>
                        </div>
                        
                        <div id="connection-status" style="
                            padding: 10px;
                            border-radius: 4px;
                            display: none;
                            font-size: 14px;
                        "></div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 关闭模态框
                document.getElementById('close-modal').onclick = () => {
                    document.body.removeChild(modal);
                };
                
                // 点击模态框外部关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
                
                // 测试连接
                document.getElementById('test-connection').onclick = async () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    const statusDiv = document.getElementById('connection-status');
                    
                    if (!apiKey) {
                        statusDiv.textContent = '请输入API密钥';
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                        statusDiv.style.display = 'block';
                        return;
                    }
                    
                    statusDiv.textContent = '正在测试连接...';
                    statusDiv.style.backgroundColor = '#e3f2fd';
                    statusDiv.style.color = '#1565c0';
                    statusDiv.style.display = 'block';
                    
                    try {
                        this.ai.setApiKey(apiKey);
                        const result = await this.ai.testConnection();
                        
                        if (result.success) {
                            statusDiv.textContent = '✅ 连接成功！';
                            statusDiv.style.backgroundColor = '#e8f5e9';
                            statusDiv.style.color = '#2e7d32';
                        } else {
                            statusDiv.textContent = `❌ 连接失败: ${result.message}`;
                            statusDiv.style.backgroundColor = '#ffebee';
                            statusDiv.style.color = '#c62828';
                        }
                    } catch (error) {
                        statusDiv.textContent = `❌ 错误: ${error.message}`;
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                    }
                };
                
                // 保存API密钥
                document.getElementById('save-api-key').onclick = () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    if (apiKey) {
                        this.ai.setApiKey(apiKey);
                        
                        const statusDiv = document.getElementById('connection-status');
                        statusDiv.textContent = '✅ API密钥已保存！';
                        statusDiv.style.backgroundColor = '#e8f5e9';
                        statusDiv.style.color = '#2e7d32';
                        statusDiv.style.display = 'block';
                        
                        // 延迟关闭模态框
                        setTimeout(() => {
                            document.body.removeChild(modal);
                        }, 1500);
                    }
                };
            },
            
            // 设置事件监听器
            setupEventListeners() {
                console.log('设置事件监听器...');
                try {
                    // 概率分布模拟相关事件
                    const generateDataBtn = document.getElementById('generate-data');
                    const clearDataBtn = document.getElementById('clear-data');
                    
                    console.log('生成数据按钮:', generateDataBtn);
                    if (generateDataBtn) {
                        generateDataBtn.addEventListener('click', () => {
                            console.log('点击生成数据按钮');
                            this.generateDistributionData();
                        });
                    }
                    
                    if (clearDataBtn) {
                        clearDataBtn.addEventListener('click', () => this.clearDistributionData());
                    }
                    
                    // 置信区间分析相关事件
                    const calculateConfidenceBtn = document.getElementById('calculate-confidence');
                    const generateConfidenceSampleBtn = document.getElementById('generate-confidence-sample');
                    
                    if (calculateConfidenceBtn) {
                        calculateConfidenceBtn.addEventListener('click', () => this.calculateConfidenceInterval());
                    }
                    
                    if (generateConfidenceSampleBtn) {
                        generateConfidenceSampleBtn.addEventListener('click', () => this.generateConfidenceSample());
                    }
                    
                    // 数据分析相关事件
                    const analyzeDataBtn = document.getElementById('analyze-data');
                    const resetAnalysisBtn = document.getElementById('reset-analysis');
                    const fileUpload = document.getElementById('file-upload');
                    
                    if (analyzeDataBtn) {
                        analyzeDataBtn.addEventListener('click', () => this.analyzeData());
                    }
                    
                    if (resetAnalysisBtn) {
                        resetAnalysisBtn.addEventListener('click', () => this.resetAnalysis());
                    }
                    
                    if (fileUpload) {
                        fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
                    }
                    
                    // 设置数据输入方式切换事件
                    document.querySelectorAll('input[name="data-input-method"]').forEach(radio => {
                        radio.addEventListener('change', () => this.switchDataInputMethod());
                    });
                    
                    // 设置AI生成数据按钮事件
                    const generateAIDataBtn = document.getElementById('generate-ai-data');
                    if (generateAIDataBtn) {
                        generateAIDataBtn.addEventListener('click', () => {
                            console.log('点击生成AI数据按钮');
                            this.generateAIData();
                        });
                    }
                    
                    console.log('事件监听器设置完成');
                } catch (error) {
                    console.error('设置事件监听器时出错:', error);
                    alert('设置事件监听器失败: ' + error.message);
                }
            },
            
            // 设置标签页切换
            setupTabs() {
                try {
                    const tabs = document.querySelectorAll('.tab');
                    tabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            const tabId = tab.getAttribute('data-tab');
                            
                            // 移除所有标签的活动状态
                            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            
                            // 隐藏所有内容
                            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                            const targetContent = document.getElementById(tabId);
                            if (targetContent) {
                                targetContent.classList.remove('hidden');
                            }
                        });
                    });
                } catch (error) {
                    console.error('设置标签页时出错:', error);
                }
            },
            
            // 设置分布类型变化事件
            setupDistributionTypeChange() {
                try {
                    const distributionType = document.getElementById('distribution-type');
                    const paramGroups = {
                        'normal': document.getElementById('normal-params'),
                        'binomial': document.getElementById('binomial-params'),
                        'poisson': document.getElementById('poisson-params'),
                        'uniform': document.getElementById('uniform-params'),
                        'exponential': document.getElementById('exponential-params')
                    };
                    
                    if (distributionType) {
                        distributionType.addEventListener('change', () => {
                            const selectedType = distributionType.value;
                            
                            // 隐藏所有参数组
                            for (const type in paramGroups) {
                                if (paramGroups[type]) {
                                    paramGroups[type].classList.add('hidden');
                                }
                            }
                            
                            // 显示选中的参数组
                            if (paramGroups[selectedType]) {
                                paramGroups[selectedType].classList.remove('hidden');
                            }
                        });
                    }
                } catch (error) {
                    console.error('设置分布类型变化时出错:', error);
                }
            },
            
            // 设置图表类型变化监听器
            setupChartTypeChangeListener() {
                try {
                    const chartTypeSelect = document.getElementById('chart-type');
                    
                    // 确保只添加一次事件监听器
                    if (chartTypeSelect && !chartTypeSelect.getAttribute('data-listener-added')) {
                        chartTypeSelect.addEventListener('change', () => {
                            // 当图表类型改变时，如果已经有分析结果，重新绘制图表
                            if (this.currentChart && this.generatedData) {
                                this.updateChart();
                            }
                        });
                        
                        // 标记已添加监听器
                        chartTypeSelect.setAttribute('data-listener-added', 'true');
                    }
                } catch (error) {
                    console.error('设置图表类型变化监听器时出错:', error);
                }
            },
            
            // 生成分布数据
            generateDistributionData() {
                console.log('开始生成分布数据...');
                try {
                    // 获取并验证元素存在性
                    const distributionTypeElement = document.getElementById('distribution-type');
                    const sampleSizeElement = document.getElementById('sample-size');
                    
                    if (!distributionTypeElement || !sampleSizeElement) {
                        throw new Error('找不到必要的DOM元素');
                    }
                    
                    const distributionType = distributionTypeElement.value;
                    const sampleSize = parseInt(sampleSizeElement.value);
                    
                    console.log('分布类型:', distributionType);
                    console.log('样本大小:', sampleSize);
                    
                    // 验证样本大小
                    if (isNaN(sampleSize) || sampleSize < 100 || sampleSize > 10000) {
                        alert('请输入有效的样本大小（100-10000）');
                        return;
                    }
                    
                    // 显示进度条
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = '正在生成数据...';
                    }
                    
                    // 模拟生成过程中的进度更新
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `正在生成数据... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // 根据不同分布类型生成数据 - 使用Promise确保异步操作的正确性
                    Promise.resolve().then(() => {
                        try {
                            let data = null;
                            
                            switch (distributionType) {
                                case 'normal':
                                    console.log('生成正态分布数据');
                                    data = this.generateNormalData(sampleSize);
                                    break;
                                case 'binomial':
                                    console.log('生成二项分布数据');
                                    data = this.generateBinomialData(sampleSize);
                                    break;
                                case 'poisson':
                                    console.log('生成泊松分布数据');
                                    data = this.generatePoissonData(sampleSize);
                                    break;
                                case 'uniform':
                                    console.log('生成均匀分布数据');
                                    data = this.generateUniformData(sampleSize);
                                    break;
                                case 'exponential':
                                    console.log('生成指数分布数据');
                                    data = this.generateExponentialData(sampleSize);
                                    break;
                                default:
                                    throw new Error('未知的分布类型');
                            }
                            
                            // 确保数据生成成功
                            if (!data || data.length === 0) {
                                throw new Error('数据生成失败，返回空数据');
                            }
                            
                            console.log('数据生成成功，长度:', data.length);
                            this.generatedData = data;
                            
                            // 更新进度条为100%
                            if (progressFill && progressText) {
                                progressFill.style.width = '100%';
                                progressText.textContent = '数据生成完成！';
                            }
                            
                            // 绘制图表
                            console.log('开始绘制图表');
                            this.plotDistributionChart(data, distributionType);
                            
                            // 计算并显示统计信息
                            console.log('开始计算统计信息');
                            this.calculateDistributionStats(data, distributionType);
                            
                            // 隐藏进度条
                            setTimeout(() => {
                                if (progressContainer) {
                                    progressContainer.classList.add('hidden');
                                }
                            }, 500);
                        } catch (error) {
                            console.error('生成数据时出错:', error);
                            alert('生成数据时出错: ' + error.message);
                            if (progressContainer) {
                                progressContainer.classList.add('hidden');
                            }
                        } finally {
                            clearInterval(interval);
                        }
                    });
                } catch (error) {
                    console.error('调用生成数据函数时出错:', error);
                    alert('生成数据失败: ' + error.message);
                }
            },
            
            // 生成正态分布数据
            generateNormalData(sampleSize) {
                const mean = parseFloat(document.getElementById('normal-mean').value);
                const std = parseFloat(document.getElementById('normal-std').value);
                
                // 验证参数
                if (isNaN(mean) || isNaN(std) || std <= 0) {
                    throw new Error('无效的正态分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // Box-Muller 转换生成正态分布随机数
                    let u1, u2;
                    do {
                        u1 = Math.random();
                        u2 = Math.random();
                    } while (u1 <= Number.EPSILON);
                    
                    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    data.push(mean + z0 * std);
                }
                
                return data;
            },
            
            // 生成二项分布数据
            generateBinomialData(sampleSize) {
                const n = parseInt(document.getElementById('binomial-n').value);
                const p = parseFloat(document.getElementById('binomial-p').value);
                
                // 验证参数
                if (isNaN(n) || isNaN(p) || n <= 0 || p < 0 || p > 1) {
                    throw new Error('无效的二项分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let successes = 0;
                    for (let j = 0; j < n; j++) {
                        if (Math.random() < p) {
                            successes++;
                        }
                    }
                    data.push(successes);
                }
                
                return data;
            },
            
            // 生成泊松分布数据
            generatePoissonData(sampleSize) {
                const lambda = parseFloat(document.getElementById('poisson-lambda').value);
                
                // 验证参数
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('无效的泊松分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let k = 0;
                    let p = 1;
                    const L = Math.exp(-lambda);
                    
                    do {
                        k++;
                        p *= Math.random();
                    } while (p > L);
                    
                    data.push(k - 1);
                }
                
                return data;
            },
            
            // 生成均匀分布数据
            generateUniformData(sampleSize) {
                const min = parseFloat(document.getElementById('uniform-min').value);
                const max = parseFloat(document.getElementById('uniform-max').value);
                
                // 验证参数
                if (isNaN(min) || isNaN(max) || min >= max) {
                    throw new Error('无效的均匀分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    data.push(min + Math.random() * (max - min));
                }
                
                return data;
            },
            
            // 生成指数分布数据
            generateExponentialData(sampleSize) {
                const lambda = parseFloat(document.getElementById('exponential-lambda').value);
                
                // 验证参数
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('无效的指数分布参数');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // 逆变换法生成指数分布
                    const u = Math.random();
                    data.push(-Math.log(1 - u) / lambda);
                }
                
                return data;
            },
            
            // 绘制分布图表
            plotDistributionChart(data, distributionType) {
                console.log('绘制分布图表');
                try {
                    const chartElement = document.getElementById('distribution-chart');
                    const chartContainer = document.getElementById('distribution-chart-container');
                    
                    if (!chartElement || !chartContainer) {
                        throw new Error('找不到图表相关的DOM元素');
                    }
                    
                    const ctx = chartElement.getContext('2d');
                    
                    // 显示图表容器
                    chartContainer.classList.remove('hidden');
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        console.log('销毁旧图表');
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 计算直方图数据
                    const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    const binWidth = (max - min) / binCount;
                    
                    const bins = Array(binCount).fill(0);
                    const binLabels = [];
                    
                    for (let i = 0; i < binCount; i++) {
                        binLabels.push((min + i * binWidth).toFixed(2));
                    }
                    
                    data.forEach(value => {
                        if (value >= min && value <= max) {
                            const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                            bins[binIndex]++;
                        }
                    });
                    
                    // 归一化频率
                    const frequencies = bins.map(count => count / data.length);
                    
                    console.log('准备创建图表');
                    // 创建图表
                    this.currentChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: binLabels,
                            datasets: [{
                                label: `${this.getDistributionName(distributionType)}分布频率`,
                                data: frequencies,
                                backgroundColor: 'rgba(74, 111, 165, 0.7)',
                                borderColor: 'rgba(74, 111, 165, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: '值'
                                    },
                                    ticks: {
                                        autoSkip: true,
                                        maxRotation: 0,
                                        callback: function(value, index, values) {
                                            // 只显示部分标签以避免拥挤
                                            return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                        }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: '频率'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return value.toFixed(3);
                                        }
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${this.getDistributionName(distributionType)}分布直方图 (样本大小: ${data.length})`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.raw;
                                            const count = Math.round(value * data.length);
                                            return `频率: ${value.toFixed(4)} (计数: ${count})`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log('图表绘制完成');
                } catch (error) {
                    console.error('绘制图表时出错:', error);
                    alert('绘制图表失败: ' + error.message);
                }
            },
            
            // 计算分布统计信息
            calculateDistributionStats(data, distributionType) {
                try {
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (statsContainer) {
                        statsContainer.innerHTML = '';
                        statsContainer.classList.remove('hidden');
                    }
                    
                    // 计算统计量
                    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
                    const sortedData = [...data].sort((a, b) => a - b);
                    const median = sortedData.length % 2 === 0
                        ? (sortedData[sortedData.length / 2 - 1] + sortedData[sortedData.length / 2]) / 2
                        : sortedData[Math.floor(sortedData.length / 2)];
                    
                    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
                    const std = Math.sqrt(variance);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    
                    // 计算四分位数
                    const q1Index = Math.floor(sortedData.length * 0.25);
                    const q3Index = Math.floor(sortedData.length * 0.75);
                    const q1 = sortedData[q1Index];
                    const q3 = sortedData[q3Index];
                    const iqr = q3 - q1;
                    
                    // 创建统计卡片
                    const stats = [
                        { label: '均值', value: mean.toFixed(4) },
                        { label: '中位数', value: median.toFixed(4) },
                        { label: '标准差', value: std.toFixed(4) },
                        { label: '方差', value: variance.toFixed(4) },
                        { label: '最小值', value: min.toFixed(4) },
                        { label: '最大值', value: max.toFixed(4) },
                        { label: '第一四分位数', value: q1.toFixed(4) },
                        { label: '第三四分位数', value: q3.toFixed(4) },
                        { label: '四分位距', value: iqr.toFixed(4) }
                    ];
                    
                    // 添加统计卡片到容器
                    stats.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        
                        const label = document.createElement('div');
                        label.className = 'stat-label';
                        label.textContent = stat.label;
                        
                        const value = document.createElement('div');
                        value.className = 'stat-value';
                        value.textContent = stat.value;
                        
                        card.appendChild(label);
                        card.appendChild(value);
                        
                        if (statsContainer) {
                            statsContainer.appendChild(card);
                        }
                    });
                } catch (error) {
                    console.error('计算统计信息时出错:', error);
                }
            },
            
            // 清除分布数据
            clearDistributionData() {
                try {
                    // 销毁图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 隐藏图表和统计信息
                    const chartContainer = document.getElementById('distribution-chart-container');
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    if (statsContainer) {
                        statsContainer.classList.add('hidden');
                    }
                    
                    // 清除数据
                    this.generatedData = null;
                } catch (error) {
                    console.error('清除数据时出错:', error);
                }
            },
            
            // 计算置信区间
            calculateConfidenceInterval() {
                try {
                    const confidenceLevel = parseFloat(document.getElementById('confidence-level').value);
                    const populationMean = parseFloat(document.getElementById('population-mean').value);
                    const populationStd = parseFloat(document.getElementById('population-std').value);
                    const sampleSize = parseInt(document.getElementById('sample-size-confidence').value);
                    
                    // 验证参数
                    if (isNaN(confidenceLevel) || isNaN(populationMean) || isNaN(populationStd) || isNaN(sampleSize) || 
                        populationStd <= 0 || sampleSize <= 0) {
                        alert('请输入有效的参数');
                        return;
                    }
                    
                    // 计算Z分数
                    const zScore = this.getZScore(confidenceLevel);
                    
                    // 计算标准误
                    const standardError = populationStd / Math.sqrt(sampleSize);
                    
                    // 计算置信区间
                    const marginOfError = zScore * standardError;
                    const lowerBound = populationMean - marginOfError;
                    const upperBound = populationMean + marginOfError;
                    
                    // 绘制置信区间图表
                    this.plotConfidenceIntervalChart(populationMean, lowerBound, upperBound, confidenceLevel);
                } catch (error) {
                    console.error('计算置信区间时出错:', error);
                    alert('计算置信区间失败，请重试');
                }
            },
            
            // 生成置信区间样本
            generateConfidenceSample() {
                try {
                    const confidenceLevel = parseFloat(document.getElementById('confidence-level').value);
                    const populationMean = parseFloat(document.getElementById('population-mean').value);
                    const populationStd = parseFloat(document.getElementById('population-std').value);
                    const sampleSize = parseInt(document.getElementById('sample-size-confidence').value);
                    
                    // 验证参数
                    if (isNaN(confidenceLevel) || isNaN(populationMean) || isNaN(populationStd) || isNaN(sampleSize) || 
                        populationStd <= 0 || sampleSize <= 0) {
                        alert('请输入有效的参数');
                        return;
                    }
                    
                    // 生成样本数据
                    const sampleData = [];
                    for (let i = 0; i < sampleSize; i++) {
                        // 生成正态分布随机数
                        let u1, u2;
                        do {
                            u1 = Math.random();
                            u2 = Math.random();
                        } while (u1 <= Number.EPSILON);
                        
                        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        sampleData.push(populationMean + z0 * populationStd);
                    }
                    
                    // 计算样本均值
                    const sampleMean = sampleData.reduce((sum, val) => sum + val, 0) / sampleData.length;
                    
                    // 计算Z分数
                    const zScore = this.getZScore(confidenceLevel);
                    
                    // 计算标准误（使用总体标准差）
                    const standardError = populationStd / Math.sqrt(sampleSize);
                    
                    // 计算置信区间
                    const marginOfError = zScore * standardError;
                    const lowerBound = sampleMean - marginOfError;
                    const upperBound = sampleMean + marginOfError;
                    
                    // 绘制置信区间图表
                    this.plotConfidenceIntervalChart(sampleMean, lowerBound, upperBound, confidenceLevel, populationMean);
                } catch (error) {
                    console.error('生成置信区间样本时出错:', error);
                    alert('生成样本失败，请重试');
                }
            },
            
            // 获取Z分数
            getZScore(confidenceLevel) {
                // 常见置信水平的Z分数
                const zScores = {
                    0.90: 1.645,
                    0.95: 1.96,
                    0.99: 2.576
                };
                
                return zScores[confidenceLevel] || 1.96; // 默认使用95%的Z分数
            },
            
            // 绘制置信区间图表
            plotConfidenceIntervalChart(mean, lowerBound, upperBound, confidenceLevel, populationMean = null) {
                try {
                    const ctx = document.getElementById('confidence-chart').getContext('2d');
                    const chartContainer = document.getElementById('confidence-chart-container');
                    
                    // 显示图表容器
                    if (chartContainer) {
                        chartContainer.classList.remove('hidden');
                    }
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    // 创建图表数据
                    const datasets = [
                        {
                            label: '置信区间',
                            data: [lowerBound, upperBound],
                            backgroundColor: 'rgba(74, 111, 165, 0.3)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        },
                        {
                            label: '均值',
                            data: [mean],
                            backgroundColor: 'rgba(249, 160, 63, 1)',
                            borderColor: 'rgba(249, 160, 63, 1)',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ];
                    
                    // 如果提供了总体均值，添加到图表中
                    if (populationMean !== null) {
                        datasets.push({
                            label: '总体均值',
                            data: [populationMean],
                            backgroundColor: 'rgba(76, 175, 80, 1)',
                            borderColor: 'rgba(76, 175, 80, 1)',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        });
                    }
                    
                    // 创建图表
                    this.currentChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [''],
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    display: false
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: '值'
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${confidenceLevel * 100}% 置信区间`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.dataset.label || '';
                                            const value = context.raw;
                                            
                                            if (label === '置信区间') {
                                                return `${label}: [${lowerBound.toFixed(4)}, ${upperBound.toFixed(4)}]`;
                                            }
                                            return `${label}: ${value.toFixed(4)}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('绘制置信区间图表时出错:', error);
                    alert('绘制图表失败，请重试');
                }
            },
            
            // 数据分析
            analyzeData() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    
                    if (inputMethod === 'distribution') {
                        // 使用分布生成的数据
                        if (!this.generatedData) {
                            alert('请先在分布模拟标签页中生成数据');
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    } else if (inputMethod === 'file') {
                        // 使用上传的文件数据
                        // 文件上传处理逻辑将在handleFileUpload中设置this.generatedData
                        if (!this.generatedData) {
                            alert('请先上传CSV文件');
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    } else if (inputMethod === 'ai') {
                        // 使用AI生成的数据
                        if (!this.generatedData) {
                            alert('请先生成AI数据');
                            return;
                        }
                        
                        this.updateChart();
                        // 执行参数估计
                        this.estimateParameters();
                    }
                } catch (error) {
                    console.error('分析数据时出错:', error);
                    alert('分析数据失败，请重试');
                }
            },
            
            // 更新图表
            updateChart() {
                try {
                    const chartType = document.getElementById('chart-type').value;
                    const ctx = document.getElementById('analysis-chart').getContext('2d');
                    const chartContainer = document.getElementById('analysis-chart-container');
                    
                    // 显示图表容器
                    if (chartContainer) {
                        chartContainer.classList.remove('hidden');
                    }
                    
                    // 销毁旧图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    const data = this.generatedData;
                    let chartConfig;
                    
                    switch (chartType) {
                        case 'histogram':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'bar':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'scatter':
                            chartConfig = this.createScatterConfig(data);
                            break;
                        case 'line':
                            chartConfig = this.createLineConfig(data);
                            break;
                        default:
                            chartConfig = this.createHistogramConfig(data);
                    }
                    
                    // 创建图表
                    this.currentChart = new Chart(ctx, chartConfig);
                } catch (error) {
                    console.error('更新图表时出错:', error);
                    alert('更新图表失败，请重试');
                }
            },
            
            // 创建直方图配置
            createHistogramConfig(data) {
                // 计算直方图数据
                const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binWidth = (max - min) / binCount;
                
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                for (let i = 0; i < binCount; i++) {
                    binLabels.push((min + i * binWidth).toFixed(2));
                }
                
                data.forEach(value => {
                    if (value >= min && value <= max) {
                        const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                        bins[binIndex]++;
                    }
                });
                
                // 归一化频率
                const frequencies = bins.map(count => count / data.length);
                
                return {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: '频率',
                            data: frequencies,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '值'
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxRotation: 0,
                                    callback: function(value, index, values) {
                                        // 只显示部分标签以避免拥挤
                                        return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                    }
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: '频率'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(3);
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `直方图分析 (样本大小: ${data.length})`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 创建散点图配置
            createScatterConfig(data) {
                // 准备散点图数据
                const scatterData = data.slice(0, 1000).map((value, index) => ({
                    x: index,
                    y: value
                }));
                
                return {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: '数据点',
                            data: scatterData,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            pointRadius: 3,
                            pointHoverRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '索引'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '值'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `散点图分析 (显示前1000个点)`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 创建折线图配置
            createLineConfig(data) {
                // 准备折线图数据（取前1000个点以避免图表过于密集）
                const displayData = data.slice(0, 1000);
                const indices = Array.from({ length: displayData.length }, (_, i) => i);
                
                return {
                    type: 'line',
                    data: {
                        labels: indices,
                        datasets: [{
                            label: '数据趋势',
                            data: displayData,
                            backgroundColor: 'rgba(74, 111, 165, 0.1)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '索引'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '值'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `折线图分析 (显示前1000个点)`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // 处理文件上传
            handleFileUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            const data = this.parseCSVData(content);
                            
                            if (data.length === 0) {
                                alert('未能从文件中解析出数据');
                                return;
                            }
                            
                            this.generatedData = data;
                            alert(`成功导入 ${data.length} 个数据点`);
                        } catch (error) {
                            console.error('解析文件时出错:', error);
                            alert('解析文件失败，请检查文件格式');
                        }
                    };
                    
                    reader.onerror = () => {
                        alert('读取文件失败');
                    };
                    
                    reader.readAsText(file);
                } catch (error) {
                    console.error('处理文件上传时出错:', error);
                    alert('上传文件失败，请重试');
                }
            },
            
            // 解析CSV数据
            parseCSVData(content) {
                // 尝试不同的CSV格式解析
                const lines = content.split(/[\r\n]+/).filter(line => line.trim() !== '');
                const data = [];
                
                // 尝试每行一个数据
                if (lines.length > 0 && lines[0].indexOf(',') === -1) {
                    for (const line of lines) {
                        const value = parseFloat(line.trim());
                        if (!isNaN(value)) {
                            data.push(value);
                        }
                    }
                } else {
                    // 尝试逗号分隔的数据
                    for (const line of lines) {
                        const values = line.split(',').map(val => parseFloat(val.trim()));
                        for (const value of values) {
                            if (!isNaN(value)) {
                                data.push(value);
                            }
                        }
                    }
                }
                
                return data;
            },
            
            // 切换数据输入方式
            switchDataInputMethod() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    const fileInputContainer = document.getElementById('file-data-input');
                    const aiInputContainer = document.getElementById('ai-data-input');
                    
                    // 处理文件输入容器
                    if (fileInputContainer) {
                        if (inputMethod === 'file') {
                            fileInputContainer.classList.remove('hidden');
                        } else {
                            fileInputContainer.classList.add('hidden');
                            // 清除文件输入
                            const fileInput = document.getElementById('file-upload');
                            if (fileInput) {
                                fileInput.value = '';
                            }
                        }
                    }
                    
                    // 处理AI输入容器
                    if (aiInputContainer) {
                        if (inputMethod === 'ai') {
                            aiInputContainer.classList.remove('hidden');
                        } else {
                            aiInputContainer.classList.add('hidden');
                        }
                    }
                } catch (error) {
                    console.error('切换数据输入方式时出错:', error);
                }
            },
            
            // AI生成数据
            generateAIData() {
                console.log('开始AI生成数据...');
                try {
                    const description = document.getElementById('ai-data-description').value;
                    const count = parseInt(document.getElementById('ai-data-count').value);
                    const seed = document.getElementById('ai-data-seed').value ? parseInt(document.getElementById('ai-data-seed').value) : null;
                    
                    // 验证输入
                    if (!description.trim()) {
                        alert('请输入数据描述');
                        return;
                    }
                    
                    if (isNaN(count) || count < 100 || count > 10000) {
                        alert('请输入有效的数据点数量（100-10000）');
                        return;
                    }
                    
                    // 显示进度条
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = 'AI正在生成数据...';
                    }
                    
                    // 模拟生成过程中的进度更新
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `AI正在生成数据... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // 定义清理函数
                    const cleanup = () => {
                        clearInterval(interval);
                        if (progressContainer) {
                            progressContainer.classList.add('hidden');
                        }
                    };
                    
                    // 尝试使用真实的AI API
                    if (this.ai && this.ai.isConfigured) {
                        console.log('使用真实AI API生成数据');
                        
                        // 构建提示词
                        const prompt = `根据以下描述生成${count}个数值数据点：\n${description}\n\n请生成一个包含${count}个数值的数组，每个数值单独一行。不要包含任何额外的文字、解释或格式，只需要纯数值数据。`;
                        
                        // 调用AI API
                        this.generateWithRealAI(prompt, count, progressFill, progressText, cleanup);
                    } else {
                        console.log('使用模拟AI生成数据（未配置真实AI API）');
                        
                        // 如果没有配置真实AI，显示提示
                        if (!this.ai) {
                            console.warn('AI集成未初始化');
                        } else {
                            console.warn('未配置AI API密钥，点击"AI设置"按钮进行配置');
                        }
                        
                        // 继续使用模拟AI生成数据
                        setTimeout(() => {
                            try {
                                // 根据描述和随机种子生成数据
                                let data = this.simulateAIDataGeneration(description, count, seed);
                                
                                // 确保数据生成成功
                                if (!data || data.length === 0) {
                                    throw new Error('AI数据生成失败，返回空数据');
                                }
                                
                                console.log('模拟AI数据生成成功，长度:', data.length);
                                this.generatedData = data;
                                
                                // 更新进度条为100%
                                if (progressFill && progressText) {
                                    progressFill.style.width = '100%';
                                    progressText.textContent = 'AI数据生成完成！';
                                }
                                
                                alert(`模拟AI数据生成成功！已生成 ${data.length} 个数据点\n\n提示：配置真实AI API可获得更准确的数据生成结果。点击"AI设置"按钮进行配置。`);
                                
                                // 隐藏进度条
                                setTimeout(() => {
                                    cleanup();
                                }, 500);
                            } catch (error) {
                                console.error('模拟AI生成数据时出错:', error);
                                alert('AI数据生成时出错: ' + error.message);
                                cleanup();
                            }
                        }, 1500);
                    }
                } catch (error) {
                    console.error('调用AI生成数据函数时出错:', error);
                    alert('AI生成数据失败: ' + error.message);
                }
            },
            
            // 使用真实AI API生成数据
            async generateWithRealAI(prompt, count, progressFill, progressText, cleanup) {
                try {
                    // 更新进度文本
                    if (progressText) {
                        progressText.textContent = '正在调用AI API...';
                    }
                    
                    // 调用DashScope API
                    const response = await fetch(`${this.ai.baseUrl}/services/aigc/text-generation/generation`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.ai.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: this.ai.model,
                            input: {
                                messages: [
                                    { role: 'user', content: prompt }
                                ]
                            }
                        })
                    });
                    
                    // 更新进度
                    if (progressFill && progressText) {
                        progressFill.style.width = '70%';
                        progressText.textContent = '正在解析AI响应...';
                    }
                    
                    if (response.ok) {
                        const result = await response.json();
                        const aiText = result.output.text;
                        
                        // 解析AI生成的数值数据
                        const lines = aiText.trim().split('\n');
                        const data = [];
                        
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (trimmedLine) {
                                const num = parseFloat(trimmedLine);
                                if (!isNaN(num)) {
                                    data.push(num);
                                }
                            }
                        }
                        
                        // 如果AI生成的数据不足，使用模拟数据补充
                        if (data.length < count * 0.5) {
                            console.warn(`AI只生成了${data.length}个数据点，使用模拟数据补充`);
                            const simulatedData = this.simulateAIDataGeneration(prompt, count - data.length, null);
                            data.push(...simulatedData);
                        } else if (data.length > count) {
                            // 如果生成的数据过多，截取前count个
                            data.length = count;
                        }
                        
                        console.log('真实AI数据生成成功，长度:', data.length);
                        this.generatedData = data;
                        
                        // 更新进度条为100%
                        if (progressFill && progressText) {
                            progressFill.style.width = '100%';
                            progressText.textContent = 'AI数据生成完成！';
                        }
                        
                        alert(`真实AI数据生成成功！已生成 ${data.length} 个数据点`);
                        
                        // 隐藏进度条
                        setTimeout(() => {
                            cleanup();
                        }, 500);
                    } else {
                        const errorText = await response.text();
                        throw new Error(`API调用失败: ${response.status} - ${errorText}`);
                    }
                } catch (error) {
                    console.error('真实AI生成数据时出错:', error);
                    alert(`真实AI生成数据失败: ${error.message}\n\n将回退到模拟AI生成...`);
                    
                    // 回退到模拟AI
                    try {
                        const data = this.simulateAIDataGeneration(prompt, count, null);
                        if (data && data.length > 0) {
                            this.generatedData = data;
                            console.log('回退到模拟AI成功，长度:', data.length);
                        }
                    } catch (e) {
                        console.error('回退到模拟AI也失败:', e);
                    } finally {
                        cleanup();
                    }
                }
            },
            
            // 模拟AI数据生成（基于描述和种子）
            simulateAIDataGeneration(description, count, seed) {
                console.log('模拟AI数据生成，描述:', description, '数量:', count, '种子:', seed);
                
                // 设置随机种子
                if (seed !== null) {
                    Math.seedrandom = function(seed) {
                        var s = seed + '';
                        Math.sin(s.charCodeAt(0))
                    };
                    Math.seedrandom(seed);
                }
                
                // 根据描述分析数据模式
                let data = [];
                const hasTrend = description.toLowerCase().includes('趋势') || description.toLowerCase().includes('trend');
                const hasVolatility = description.toLowerCase().includes('波动') || description.toLowerCase().includes('volatility');
                const hasSeasonality = description.toLowerCase().includes('季节性') || description.toLowerCase().includes('seasonal');
                const isStockLike = description.toLowerCase().includes('股票') || description.toLowerCase().includes('stock') || description.toLowerCase().includes('price');
                const isNormal = description.toLowerCase().includes('正态') || description.toLowerCase().includes('normal');
                const isUniform = description.toLowerCase().includes('均匀') || description.toLowerCase().includes('uniform');
                
                // 根据不同特征生成数据
                if (isNormal) {
                    // 正态分布数据
                    const mean = 50 + Math.random() * 50;
                    const stdDev = 10 + Math.random() * 20;
                    for (let i = 0; i < count; i++) {
                        data.push(this.normalRandom(mean, stdDev));
                    }
                } else if (isUniform) {
                    // 均匀分布数据
                    const min = Math.random() * 100;
                    const max = min + 100 + Math.random() * 100;
                    for (let i = 0; i < count; i++) {
                        data.push(min + Math.random() * (max - min));
                    }
                } else if (isStockLike || hasTrend) {
                    // 股票价格类数据（带趋势）
                    let price = 100 + Math.random() * 100;
                    const trend = (Math.random() - 0.45) * 2; // 轻微正趋势
                    const volatility = hasVolatility ? (0.01 + Math.random() * 0.02) : 0.01;
                    
                    for (let i = 0; i < count; i++) {
                        // 添加季节性影响
                        const seasonal = hasSeasonality ? Math.sin(i / 20) * 5 : 0;
                        // 添加随机波动
                        const randomChange = (Math.random() - 0.5) * 2 * volatility * price;
                        // 更新价格
                        price = price * (1 + trend / 100) + randomChange + seasonal;
                        // 确保价格为正
                        price = Math.max(price, 0.1);
                        data.push(price);
                    }
                } else {
                    // 默认混合分布数据
                    for (let i = 0; i < count; i++) {
                        // 根据描述中可能包含的关键词调整生成逻辑
                        if (description.toLowerCase().includes('增长') || description.toLowerCase().includes('increase')) {
                            // 增长趋势数据
                            data.push(100 + i * (0.5 + Math.random() * 0.5) + (Math.random() - 0.5) * 20);
                        } else if (description.toLowerCase().includes('周期') || description.toLowerCase().includes('cycle')) {
                            // 周期性数据
                            data.push(100 + Math.sin(i / 10) * 50 + (Math.random() - 0.5) * 20);
                        } else {
                            // 默认正态分布带一些变化
                            data.push(100 + (Math.random() - 0.5) * 100);
                        }
                    }
                }
                
                return data;
            },
            
            // 正态分布随机数生成
            normalRandom(mean, stdDev) {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                return mean + z * stdDev;
            },
            
            // 重置分析
            resetAnalysis() {
                try {
                    // 销毁图表
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // 隐藏图表容器
                    const chartContainer = document.getElementById('analysis-chart-container');
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    // 重置文件输入
                    const fileInput = document.getElementById('file-upload');
                    if (fileInput) {
                        fileInput.value = '';
                    }
                    
                    // 重置AI数据输入
                    const aiDescription = document.getElementById('ai-data-description');
                    const aiDataCount = document.getElementById('ai-data-count');
                    const aiDataSeed = document.getElementById('ai-data-seed');
                    
                    if (aiDescription) {
                        aiDescription.value = '';
                    }
                    
                    if (aiDataCount) {
                        aiDataCount.value = '1000';
                    }
                    
                    if (aiDataSeed) {
                        aiDataSeed.value = '';
                    }
                    
                    // 切换回分布输入方式
                    const distributionRadio = document.querySelector('input[name="data-input-method"][value="distribution"]');
                    if (distributionRadio) {
                        distributionRadio.checked = true;
                        this.switchDataInputMethod();
                    }
                } catch (error) {
                    console.error('重置分析时出错:', error);
                }
            },
            
            // 获取分布名称
            getDistributionName(type) {
                const names = {
                    'normal': '正态',
                    'binomial': '二项',
                    'poisson': '泊松',
                    'uniform': '均匀',
                    'exponential': '指数'
                };
                
                return names[type] || type;
            },
            
            // 假设检验相关方法
            initHypothesisTesting() {
                // 确保Math.erf函数可用，这对正态分布计算至关重要
                this.ensureMathErf();
                
                // 检验类型变化事件
                const testTypeElement = document.getElementById('test-type');
                if (testTypeElement) {
                    testTypeElement.addEventListener('change', () => {
                        try {
                            this.toggleTestParameters();
                        } catch (error) {
                            console.error('切换检验参数时出错:', error);
                        }
                    });
                }
                
                // 样本方法变化事件
                const sampleMethodElement = document.getElementById('sample-method');
                const manualSampleElement = document.getElementById('manual-sample-input');
                if (sampleMethodElement && manualSampleElement) {
                    sampleMethodElement.addEventListener('change', () => {
                        try {
                            const method = sampleMethodElement.value;
                            manualSampleElement.classList.toggle('hidden', method !== 'manual-entry');
                        } catch (error) {
                            console.error('切换样本方法时出错:', error);
                        }
                    });
                }
                
                // 计算检验按钮事件
                const calculateButton = document.getElementById('calculate-test');
                if (calculateButton) {
                    calculateButton.addEventListener('click', () => {
                        try {
                            this.calculateHypothesisTest();
                        } catch (error) {
                            console.error('计算假设检验时出错:', error);
                            alert('计算错误: ' + error.message);
                        }
                    });
                }
                
                // 清除结果按钮事件
                const clearButton = document.getElementById('clear-test-results');
                if (clearButton) {
                    clearButton.addEventListener('click', () => {
                        try {
                            this.clearTestResults();
                        } catch (error) {
                            console.error('清除检验结果时出错:', error);
                        }
                    });
                }
                
                // 初始调用一次参数切换函数
                try {
                    this.toggleTestParameters();
                } catch (error) {
                    console.error('初始化检验参数时出错:', error);
                }
            },
            
            toggleTestParameters() {
                const testType = document.getElementById('test-type').value;
                
                // 显示/隐藏不同检验类型的参数区域
                document.getElementById('one-sample-params').classList.toggle('hidden', 
                    testType !== 'z-test' && testType !== 't-test');
                document.getElementById('two-sample-params').classList.toggle('hidden', 
                    testType !== 'two-sample-t');
                document.getElementById('anova-params').classList.toggle('hidden', 
                    testType !== 'anova');
                
                // 对于方差分析，默认使用手动输入
                if (testType === 'anova') {
                    document.getElementById('sample-method').value = 'manual-entry';
                    document.getElementById('manual-sample-input').classList.remove('hidden');
                }
            },
            
            calculateHypothesisTest() {
                try {
                    const testType = document.getElementById('test-type').value;
                    const significanceLevel = parseFloat(document.getElementById('significance-level').value);
                    
                    // 验证显著性水平
                    if (isNaN(significanceLevel) || significanceLevel <= 0 || significanceLevel >= 1) {
                        throw new Error('显著性水平必须是0到1之间的数值');
                    }
                    
                    let results = null;
                    
                    switch(testType) {
                        case 'z-test':
                            const hypothesizedMeanZ = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanZ)) {
                                throw new Error('请输入有效的假设均值');
                            }
                            results = this.calculateZTest(significanceLevel, hypothesizedMeanZ);
                            break;
                        case 't-test':
                            const hypothesizedMeanT = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanT)) {
                                throw new Error('请输入有效的假设均值');
                            }
                            results = this.calculateTTest(significanceLevel, hypothesizedMeanT);
                            break;
                        case 'two-sample-t':
                            const testDirectionT = document.getElementById('test-direction').value;
                            results = this.calculateTwoSampleTTest(significanceLevel, testDirectionT);
                            break;
                        case 'anova':
                            results = this.calculateANOVA(significanceLevel);
                            break;
                        default:
                            throw new Error('未知的检验类型');
                    }
                    
                    if (results) {
                        this.displayTestResults(results);
                    }
                } catch (error) {
                    console.error('假设检验计算错误:', error);
                    alert('计算错误: ' + error.message);
                }
            },
            
            calculateZTest(significanceLevel, hypothesizedMean) {
                // 从DOM获取检验方向
                const testDirection = document.getElementById('test-direction').value;
                const populationStd = document.getElementById('population-std').value;
                
                // 验证数据和参数
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('请先在概率分布模拟或数据分析中生成或导入数据');
                }
                
                // 验证总体标准差
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('请输入有效的总体标准差');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 计算p值
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // 计算临界值
                let criticalValue;
                const alpha = significanceLevel;
                
                if (testDirection === 'two-tailed') {
                    criticalValue = this.getZScore(1 - alpha/2);
                } else if (testDirection === 'left-tailed') {
                    criticalValue = -this.getZScore(1 - alpha);
                } else {
                    criticalValue = this.getZScore(1 - alpha);
                }
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Z检验',
                    sampleMean,
                    hypothesizedMean,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设`
                };
            },
            
            calculateTTest(significanceLevel, hypothesizedMean) {
                // 从DOM获取检验方向
                const testDirection = document.getElementById('test-direction').value;
                
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('请先在概率分布模拟或数据分析中生成或导入数据');
                }
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleStd = this.calculateStandardDeviation(this.generatedData);
                const sampleSize = this.generatedData.length;
                const degreesOfFreedom = sampleSize - 1;
                const standardError = sampleStd / Math.sqrt(sampleSize);
                const tScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 这里简化处理，使用近似的t分布p值计算
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                // 计算临界值
                let criticalValue = this.approximateTCriticalValue(degreesOfFreedom, significanceLevel, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'T检验',
                    sampleMean,
                    hypothesizedMean,
                    sampleStd,
                    sampleSize,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设`
                };
            },
            
            calculateTwoSampleTTest(significanceLevel, testDirection) {
                let sample1, sample2;
                
                const sampleMethod = document.getElementById('sample-method').value;
                
                if (sampleMethod === 'use-generated') {
                    if (!this.generatedData || this.generatedData.length < 2) {
                        throw new Error('使用已生成数据需要至少2个数据点');
                    }
                    // 简单地将数据分成两半
                    const midPoint = Math.floor(this.generatedData.length / 2);
                    sample1 = this.generatedData.slice(0, midPoint);
                    sample2 = this.generatedData.slice(midPoint);
                } else {
                    // 手动输入
                    const sample1Text = document.getElementById('sample1-data').value.trim();
                    const sample2Text = document.getElementById('sample2-data').value.trim();
                    
                    if (!sample1Text || !sample2Text) {
                        throw new Error('请输入两个样本的数据');
                    }
                    
                    sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    
                    if (sample1.length === 0 || sample2.length === 0) {
                        throw new Error('样本数据格式错误，请使用逗号分隔的数字');
                    }
                }
                
                // 计算样本统计量
                const mean1 = this.calculateMean(sample1);
                const mean2 = this.calculateMean(sample2);
                const std1 = this.calculateStandardDeviation(sample1);
                const std2 = this.calculateStandardDeviation(sample2);
                const n1 = sample1.length;
                const n2 = sample2.length;
                
                // 计算合并标准差
                const pooledVariance = ((n1 - 1) * std1 * std1 + (n2 - 1) * std2 * std2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVariance * (1/n1 + 1/n2));
                const tScore = (mean1 - mean2) / standardError;
                const degreesOfFreedom = n1 + n2 - 2;
                
                // 近似p值
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: '双样本T检验',
                    mean1,
                    mean2,
                    std1,
                    std2,
                    n1,
                    n2,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设（两个总体均值相等）` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设（两个总体均值相等）`
                };
            },
            
            calculateANOVA(significanceLevel) {
                const sample1Text = document.getElementById('sample1-data').value.trim();
                const sample2Text = document.getElementById('sample2-data').value.trim();
                
                if (!sample1Text || !sample2Text) {
                    throw new Error('方差分析需要至少两个样本的数据');
                }
                
                const sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                const sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                
                if (sample1.length === 0 || sample2.length === 0) {
                    throw new Error('样本数据格式错误，请使用逗号分隔的数字');
                }
                
                const groups = [sample1, sample2];
                const k = groups.length; // 组数
                const n = groups.reduce((sum, group) => sum + group.length, 0); // 总样本数
                
                // 计算各组均值和总均值
                const groupMeans = groups.map(group => this.calculateMean(group));
                const grandMean = this.calculateMean(groups.flat());
                
                // 计算组间平方和
                let ssb = 0;
                groups.forEach((group, index) => {
                    ssb += group.length * Math.pow(groupMeans[index] - grandMean, 2);
                });
                
                // 计算组内平方和
                let ssw = 0;
                groups.forEach((group, index) => {
                    group.forEach(value => {
                        ssw += Math.pow(value - groupMeans[index], 2);
                    });
                });
                
                // 计算均方
                const msb = ssb / (k - 1); // 组间均方
                const msw = ssw / (n - k); // 组内均方
                
                // 计算F统计量
                const fStatistic = msb / msw;
                
                // 简化的p值计算
                const pValue = this.approximateFPValue(fStatistic, k - 1, n - k);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: '单因素方差分析',
                    groups: k,
                    totalSamples: n,
                    groupMeans,
                    grandMean,
                    fStatistic,
                    degreesOfFreedom: `${k-1}, ${n-k}`,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设（各组均值相等）` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设（各组均值相等）`
                };
            },
            
            displayTestResults(results) {
                const summaryContainer = document.getElementById('test-summary');
                summaryContainer.innerHTML = '';
                
                // 创建结果卡片
                const createStatCard = (title, value, description = '') => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.innerHTML = `
                        <h4>${title}</h4>
                        <div class="stat-value">${value}</div>
                        ${description ? `<div class="stat-description">${description}</div>` : ''}
                    `;
                    summaryContainer.appendChild(card);
                };
                
                // 根据检验类型显示不同的结果
                if (results.testType === 'Z检验' || results.testType === 'T检验') {
                    createStatCard('检验类型', results.testType);
                    createStatCard('样本均值', results.sampleMean ? results.sampleMean.toFixed(4) : 'N/A');
                    createStatCard('假设均值', results.hypothesizedMean);
                    createStatCard('样本量', results.sampleSize);
                    
                    if (results.testType === 'Z检验') {
                        createStatCard('Z统计量', results.zScore ? results.zScore.toFixed(4) : 'N/A');
                    } else {
                        createStatCard('T统计量', results.tScore ? results.tScore.toFixed(4) : 'N/A');
                        createStatCard('自由度', results.degreesOfFreedom);
                    }
                    
                    createStatCard('P值', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('显著性水平', results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>检验结论</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                    
                    // 绘制图表
                    this.plotTestChart(results);
                } else if (results.testType === '双样本T检验') {
                    createStatCard('检验类型', results.testType);
                    createStatCard('样本1均值', results.mean1 ? results.mean1.toFixed(4) : 'N/A');
                    createStatCard('样本2均值', results.mean2 ? results.mean2.toFixed(4) : 'N/A');
                    createStatCard('样本1标准差', results.std1 ? results.std1.toFixed(4) : 'N/A');
                    createStatCard('样本2标准差', results.std2 ? results.std2.toFixed(4) : 'N/A');
                    createStatCard('样本1量', results.n1);
                    createStatCard('样本2量', results.n2);
                    createStatCard('T统计量', results.tScore ? results.tScore.toFixed(4) : 'N/A');
                    createStatCard('自由度', results.degreesOfFreedom);
                    createStatCard('P值', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('显著性水平', results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>检验结论</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                } else if (results.testType === '单因素方差分析') {
                    createStatCard('检验类型', results.testType);
                    createStatCard('组数', results.groups);
                    createStatCard('总样本数', results.totalSamples);
                    createStatCard('F统计量', results.fStatistic ? results.fStatistic.toFixed(4) : 'N/A');
                    createStatCard('自由度', results.degreesOfFreedom);
                    createStatCard('P值', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('显著性水平', results.significanceLevel);
                    
                    // 显示各组均值
                    if (results.groupMeans && Array.isArray(results.groupMeans)) {
                        results.groupMeans.forEach((mean, index) => {
                            createStatCard(`组 ${index + 1} 均值`, mean ? mean.toFixed(4) : 'N/A');
                        });
                    }
                    
                    createStatCard('总均值', results.grandMean ? results.grandMean.toFixed(4) : 'N/A');
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>检验结论</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                }
                
                // 显示结果区域
                document.getElementById('test-results').classList.remove('hidden');
                document.getElementById('test-chart-container').classList.remove('hidden');
            },
            
            plotTestChart(results) {
                try {
                    const ctx = document.getElementById('test-chart')?.getContext('2d');
                    if (!ctx) {
                        console.error('图表上下文未找到');
                        return;
                    }
                    
                    // 销毁旧图表
                    if (this.testChart) {
                        this.testChart.destroy();
                    }
                    
                    let chartData = null;
                    let chartOptions = null;
                    
                    if (results.testType === 'Z检验' || results.testType === 'T检验') {
                        // 为Z检验或T检验创建分布图
                        const xValues = [];
                        const distributionValues = [];
                        const testStat = results.testType === 'Z检验' ? results.zScore : results.tScore;
                        
                        // 验证必要的数据存在
                        if (testStat === undefined || testStat === null) {
                            console.error('检验统计量不存在');
                            return;
                        }
                        
                        // 生成分布曲线数据
                        const min = Math.min(-4, testStat - 1);
                        const max = Math.max(4, testStat + 1);
                        for (let x = min; x <= max; x += 0.1) {
                            xValues.push(x);
                            if (results.testType === 'Z检验') {
                                distributionValues.push(this.normalPDF(x));
                            } else if (results.degreesOfFreedom) {
                                distributionValues.push(this.tDistributionPDF(x, results.degreesOfFreedom));
                            } else {
                                distributionValues.push(0); // 避免自由度不存在导致的错误
                            }
                        }
                        
                        // 创建p值区域数据
                        const pValueArea = [];
                        const testDirection = results.testDirection || 'two-tailed';
                        
                        if (testDirection === 'two-tailed') {
                            // 双侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (Math.abs(xValues[i]) >= Math.abs(testStat)) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else if (testDirection === 'right-tailed') {
                            // 右侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] >= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else {
                            // 左侧检验
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] <= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        }
                        
                        // 定义图表数据
                        chartData = {
                            labels: xValues,
                            datasets: [
                                {
                                    label: results.testType === 'Z检验' ? '标准正态分布' : 'T分布',
                                    data: distributionValues,
                                    borderColor: 'blue',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'p值区域',
                                    data: pValueArea,
                                    borderColor: 'red',
                                    backgroundColor: 'rgba(255, 99, 132, 0.3)',
                                    borderWidth: 0,
                                    fill: true
                                }
                            ]
                        };
                        
                        // 定义图表选项
                        chartOptions = {
                            responsive: true,
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${results.testType} 分布与p值可视化`
                                },
                                legend: {
                                    position: 'top'
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: results.testType === 'Z检验' ? 'Z值' : 'T值'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: '概率密度'
                                    },
                                    min: 0
                                }
                            }
                        };
                    }
                    
                    // 创建新图表
                    if (chartData && chartOptions && typeof Chart !== 'undefined') {
                        try {
                            this.testChart = new Chart(ctx, {
                                type: 'line',
                                data: chartData,
                                options: chartOptions
                            });
                        } catch (chartError) {
                            console.error('图表创建失败:', chartError);
                        }
                    }
                } catch (error) {
                    console.error('图表处理错误:', error);
                }
            },
              
              clearTestResults() {
                document.getElementById('test-results').classList.add('hidden');
                document.getElementById('test-chart-container').classList.add('hidden');
                
                if (this.testChart) {
                    this.testChart.destroy();
                    this.testChart = null;
                }
            },
            
            // 缺失的Z检验计算方法
            calculateZTest(significanceLevel, hypothesizedMean, testDirection) {
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('请先在概率分布模拟或数据分析中生成或导入数据');
                }
                
                // 计算样本统计量
                const sampleMean = this.calculateMean(this.generatedData);
                const populationStd = document.getElementById('population-std').value;
                
                // 验证总体标准差是否有效
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('请输入有效的总体标准差');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // 计算p值
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // 计算临界值
                let criticalValue = this.getZScore(1 - significanceLevel/2);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Z检验',
                    sampleMean,
                    hypothesizedMean,
                    populationStd: populationStdFloat,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `在显著性水平 α = ${significanceLevel} 下，拒绝原假设` : 
                        `在显著性水平 α = ${significanceLevel} 下，不拒绝原假设`
                };
            },
            
            // 缺失的Z分数获取方法
            getZScore(probability) {
                // 使用反误差函数计算Z分数
                // 使用近似公式计算逆正态分布
                if (probability <= 0) return -Infinity;
                if (probability >= 1) return Infinity;
                
                // Box-Muller变换的逆过程近似
                const z = Math.sqrt(-2 * Math.log(1 - probability)) * Math.cos(2 * Math.PI * probability);
                return z;
            },
            
            // 改进的T检验p值计算
            approximateTPValue(tScore, degreesOfFreedom, testDirection) {
                // 更精确的T分布p值计算
                try {
                    if (degreesOfFreedom > 30) {
                        // 大样本情况下用正态分布近似
                        const cumulativeProbability = this.normalCDF(tScore);
                        
                        switch(testDirection) {
                            case 'two-tailed':
                                return 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                            case 'left-tailed':
                                return cumulativeProbability;
                            case 'right-tailed':
                                return 1 - cumulativeProbability;
                        }
                    }
                    
                    // 使用更精确的近似计算
                    const absT = Math.abs(tScore);
                    
                    // 基于自由度和t统计量的更精确近似
                    // 这里使用更平滑的近似公式
                    const scaledT = absT / Math.sqrt(degreesOfFreedom / (degreesOfFreedom - 2));
                    let pValue = 1.0 / (1 + Math.pow(scaledT, degreesOfFreedom/2) * 0.5);
                    
                    // 调整p值使其在合理范围内
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    if (testDirection === 'two-tailed') {
                        pValue *= 2;
                    }
                    
                    return pValue;
                } catch (error) {
                    console.error('计算p值时出错:', error);
                    // 出错时返回默认值
                    return 0.5;
                }
            },
            
            // 改进的T临界值计算
            approximateTCriticalValue(degreesOfFreedom, alpha, testDirection) {
                try {
                    // 更精确的临界值计算
                    if (degreesOfFreedom > 100) {
                        // 使用Z临界值
                        return this.getZScore(1 - alpha/2);
                    }
                    
                    // 基于自由度的更精确临界值计算
                    // 使用近似公式
                    const z = this.getZScore(1 - alpha/2);
                    const correction = (z*z*z + z) / (4 * degreesOfFreedom);
                    const criticalValue = z + correction;
                    
                    // 根据检验方向调整
                    if (testDirection === 'left-tailed') {
                        return -criticalValue;
                    } else if (testDirection === 'right-tailed') {
                        return criticalValue;
                    }
                    
                    return criticalValue; // 双侧检验返回正临界值
                } catch (error) {
                    console.error('计算临界值时出错:', error);
                    // 出错时返回默认值
                    return 1.96; // 默认Z临界值
                }
            },
            
            // 改进的F检验p值计算
            approximateFPValue(fStatistic, dfBetween, dfWithin) {
                try {
                    if (fStatistic <= 0) return 1.0;
                    
                    // 使用更精确的F分布p值近似
                    // 使用Satterthwaite近似
                    const logF = Math.log(fStatistic);
                    const logNumerator = dfBetween / 2 * logF;
                    const logDenominator = Math.log(1 + (dfBetween / dfWithin) * fStatistic) * (dfBetween + dfWithin) / 2;
                    
                    // 简化的近似公式
                    let pValue = 1.0 / (1 + Math.exp(logNumerator - logDenominator));
                    
                    // 调整p值使其在合理范围内
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    return pValue;
                } catch (error) {
                    console.error('计算F检验p值时出错:', error);
                    // 出错时返回默认值
                    return 0.5;
                }
            },
            
            // 确保Math.erf函数可用的polyfill
            ensureMathErf() {
                if (!Math.erf) {
                    // 添加误差函数的polyfill
                    Math.erf = function(x) {
                        // 简化的误差函数实现
                        const z = Math.abs(x);
                        const t = 1.0 / (1.0 + z / 2.5);
                        const a1 = 0.254829592;
                        const a2 = -0.284496736;
                        const a3 = 1.421413741;
                        const a4 = -1.453152027;
                        const a5 = 1.061405429;
                        const erf = 1 - t * Math.exp(-z * z + a1 * t + a2 * t * t + a3 * t * t * t + a4 * t * t * t * t + a5 * t * t * t * t * t);
                        return x >= 0 ? erf : -erf;
                    };
                }
            },
            
            // 辅助统计方法
            calculateMean(data) {
                // 输入验证
                if (!Array.isArray(data) || data.length === 0) {
                    console.error('calculateMean: 无效的数据数组');
                    return 0;
                }
                
                try {
                    // 过滤掉非数值和NaN值
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length === 0) {
                        console.error('calculateMean: 数组中没有有效数值');
                        return 0;
                    }
                    
                    return validData.reduce((sum, value) => sum + value, 0) / validData.length;
                } catch (error) {
                    console.error('calculateMean: 计算均值时出错', error);
                    return 0;
                }
            },
            
            calculateStandardDeviation(data) {
                try {
                    // 输入验证
                    if (!Array.isArray(data) || data.length <= 1) {
                        console.error('calculateStandardDeviation: 数据数组长度不足');
                        return 0;
                    }
                    
                    const mean = this.calculateMean(data);
                    
                    // 过滤掉非数值和NaN值
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length <= 1) {
                        console.error('calculateStandardDeviation: 有效数据点不足');
                        return 0;
                    }
                    
                    const squaredDifferences = validData.map(value => Math.pow(value - mean, 2));
                    const variance = squaredDifferences.reduce((sum, value) => sum + value, 0) / (validData.length - 1);
                    return Math.sqrt(variance);
                } catch (error) {
                    console.error('calculateStandardDeviation: 计算标准差时出错', error);
                    return 0;
                }
            },
            
            // 正态分布CDF (使用近似计算)
            normalCDF(x) {
                return 0.5 * (1 + Math.erf(x / Math.sqrt(2)));
            },
            
            // 正态分布PDF
            normalPDF(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            },
            
            // T分布PDF近似
            tDistributionPDF(x, df) {
                const gamma = this.approximateGamma((df + 1) / 2) / (Math.sqrt(df * Math.PI) * this.approximateGamma(df / 2));
                return gamma * Math.pow(1 + x * x / df, -(df + 1) / 2);
            },
            
            // 近似伽马函数
            approximateGamma(z) {
                // 简化的伽马函数近似
                const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
                
                if (z < 0.5) {
                    return Math.PI / (Math.sin(Math.PI * z) * this.approximateGamma(1 - z));
                }
                
                z -= 1;
                let x = p[0];
                for (let i = 1; i < p.length; i++) {
                    x += p[i] / (z + i);
                }
                
                const t = z + p.length - 0.5;
                return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
            }
        };
        
        // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，开始初始化应用');
            StatApp.init();
        });
    </script>
</body>
</html>